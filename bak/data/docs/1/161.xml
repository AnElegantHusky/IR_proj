<?xml version='1.0' encoding='utf-8'?>
<doc><id>161</id><url>https://docs.python.org/zh-cn/3/library/html.parser.html</url><title> --- 简单的 HTML 和 XHTML 解析器</title><body>源代码： Lib/html/parser.py
这个模块定义了一个 HTMLParser 类，为 HTML（超文本标记语言）和 XHTML 文本文件解析提供基础。
创建一个能解析无效标记的解析器实例。
如果 convert_charrefs 为 True (默认值)，则所有字符引用( script/style   元素中的除外)都会自动转换为相应的 Unicode 字符。
一个 HTMLParser 类的实例用来接受 HTML 数据，并在标记开始、标记结束、文本、注释和其他元素标记出现的时候调用对应的方法。要实现具体的行为，请使用 HTMLParser 的子类并重载其方法。
这个解析器不检查结束标记是否与开始标记匹配，也不会因外层元素完毕而隐式关闭了的元素引发结束标记处理。
在 3.4 版更改: convert_charrefs 关键字参数被添加。
在 3.5 版更改: convert_charrefs 参数的默认值现在为 True。
下面是简单的 HTML 解析器的一个基本示例，使用 HTMLParser 类，当遇到开始标记、结束标记以及数据的时候将内容打印出来。
输出是:
HTMLParser 实例有下列方法：
填充一些文本到解析器中。如果包含完整的元素，则被处理；如果数据不完整，将被缓冲直到更多的数据被填充，或者 close() 被调用。data 必须为 str 类型。
如同后面跟着一个文件结束标记一样，强制处理所有缓冲数据。这个方法能被派生类重新定义，用于在输入的末尾定义附加处理，但是重定义的版本应当始终调用基类 HTMLParser 的 close() 方法。
重置实例。丢失所有未处理的数据。在实例化阶段被隐式调用。
返回当前行号和偏移值。
返回最近打开的开始标记中的文本。 结构化处理时通常应该不需要这个，但在处理“已部署”的 HTML 或是在以最小改变来重新生成输入时可能会有用处（例如可以保留属性间的空格等）。
下列方法将在遇到数据或者标记元素的时候被调用。他们需要在子类中重载。基类的实现中没有任何实际操作（除了 handle_startendtag() ）：
这个方法在标签开始的时候被调用（例如： &lt;div id="main"&gt; ）。
tag 参数是小写的标记名。attrs 参数是一个 (name, value) 形式的列表，包含了所有在标记的 &lt;&gt;  括号中找到的属性。name 转换为小写，value 的引号被去除，字符和实体引用都会被替换。
实例中，对于标签 &lt;A HREF="https://www.cwi.nl/"&gt;，这个方法将以下列形式被调用 handle_starttag('a', [('href', 'https://www.cwi.nl/')]) 。
html.entities 中的所有实体引用，会被替换为属性值。
此方法被用来处理元素的结束标记（例如： &lt;/div&gt; ）。
tag 参数是小写的标签名。
类似于 handle_starttag(), 只是在解析器遇到 XHTML 样式的空标记时被调用（ &lt;img ... /&gt;）。这个方法能被需要这种特殊词法信息的子类重载；默认实现仅简单调用 handle_starttag() 和 handle_endtag() 。
这个方法被用来处理任意数据（例如：文本节点和 &lt;script&gt;...&lt;/script&gt; 以及 &lt;style&gt;...&lt;/style&gt; 中的内容）。
这个方法被用于处理 &amp;name; 形式的命名字符引用（例如 &amp;gt;），其中 name 是通用的实体引用（例如： 'gt'）。如果 convert_charrefs 为 True，该方法永远不会被调用。
这个方法被用来处理 &amp;#NNN; 和 &amp;#xNNN; 形式的十进制和十六进制字符引用。例如，&amp;gt; 等效的十进制形式为 &amp;#62; ，而十六进制形式为 &amp;#x3E; ；在这种情况下，方法将收到  '62' 或 'x3E' 。如果 convert_charrefs 为 True ，则该方法永远不会被调用。
这个方法在遇到注释的时候被调用（例如： &lt;!--comment--&gt; ）。
例如， &lt;!-- comment --&gt; 这个注释会用 ' comment ' 作为参数调用此方法。
Internet Explorer 条件注释（condcoms）的内容也被发送到这个方法，因此，对于 &lt;!--[if IE 9]&gt;IE9-specific content&lt;![endif]--&gt; ，这个方法将接收到 '[if IE 9]&gt;IE9-specific content&lt;![endif]' 。
这个方法用来处理 HTML doctype 申明（例如 &lt;!DOCTYPE html&gt; ）。
decl 形参为 &lt;!...&gt; 标记中的所有内容（例如： 'DOCTYPE html' ）。
此方法在遇到处理指令的时候被调用。data 形参将包含整个处理指令。例如，对于处理指令 &lt;?proc color='red'&gt; ，这个方法将以 handle_pi("proc color='red'") 形式被调用。它旨在被派生类重载；基类实现中无任何实际操作。
注解
HTMLParser 类使用 SGML 语法规则处理指令。使用 '?' 结尾的 XHTML 处理指令将导致 '?' 包含在 data 中。
当解析器读到无法识别的声明时，此方法被调用。
data 形参为 &lt;![...]&gt; 标记中的所有内容。某些时候对派生类的重载很有用。基类实现中无任何实际操作。
下面的类实现了一个解析器，用于更多示例的演示:
解析一个文档类型声明:
解析一个具有一些属性和标题的元素:
script 和 style 元素中的内容原样返回，无需进一步解析:
解析注释:
解析命名或数字形式的字符引用，并把他们转换到正确的字符（注意：这 3 种转义都是 '&gt;' ）:
填充不完整的块给 feed() 执行，handle_data() 可能会多次调用（除非 convert_charrefs 被设置为 True ）:
解析无效的 HTML (例如：未引用的属性）也能正常运行:
html --- 超文本标记语言支持
html.entities --- HTML 一般实体的定义
</body></doc>