<?xml version='1.0' encoding='utf-8'?>
<doc><id>23</id><url>https://docs.python.org/zh-cn/3/howto/instrumentation.html</url><title>使用 DTrace 和 SystemTap 检测CPython</title><body>David Malcolm
Łukasz Langa
DTrace和SystemTap是监控工具，它们都提供了一种检查计算机系统上的进程的方法。 它们都使用特定领域的语言，允许用户编写脚本，其中：
进程监视的过滤器
从感兴趣的进程中收集数据
生成有关数据的报告
从Python 3.6开始，CPython可以使用嵌入式“标记”构建，也称为“探测器”，可以通过DTrace或SystemTap脚本观察，从而更容易监视系统上的CPython进程正在做什么。
CPython implementation detail: DTrace标记是CPython解释器的实现细节。 不保证CPython版本之间的探针兼容性。 更改CPython版本时，DTrace脚本可能会停止工作或无法正常工作而不会发出警告。
macOS内置了对DTrace的支持。 在Linux上，为了使用SystemTap的嵌入式标记构建CPython，必须安装SystemTap开发工具。
在Linux机器上，这可以通过：
或者：
然后必须将CPython配置为``--with-dtrace``：
在macOS上，您可以通过在后台运行Python进程列出可用的DTrace探测器，并列出Python程序提供的所有探测器：
在Linux上，您可以通过查看是否包含“.note.stapsdt”部分来验证构建的二进制文件中是否存在SystemTap静态标记。
如果您已将Python构建为共享库（使用--enable-shared），则需要在共享库中查找。 例如：
足够现代的readelf命令可以打印元数据：
上述元数据包含SystemTap的信息，描述如何修补策略性放置的机器代码指令以启用SystemTap脚本使用的跟踪钩子。
下面的 DTrace 脚本示例可以用来显示一个 Python 脚本的调用/返回层次结构，只在调用名为 "start" 的函数内进行跟踪。换句话说，导入时的函数调用不会被列出。
它可以这样调用:
输出结果会像这样:
使用 SystemTap 集成的底层方法是直接使用静态标记。 这需要你显式地说明包含它们的二进制文件。
例如，这个SystemTap脚本可以用来显示Python脚本的调用/返回层次结构：
它可以这样调用:
输出结果会像这样:
其中的列是：
脚本开始后经过的微秒数
可执行文件的名字
进程的PID
其余部分则表示脚本执行时的调用/返回层次结构。
对于 --enable-shared 构建的CPython来说，这些标记是包含在libpython共享库中的，探针的点状路径需要反映这一点。比如上面例子中的这一行：
应改为：
（假设是 CPython 3.6 的调试构建）
这个标记表示一个Python函数的执行已经开始。它只对纯 Python （字节码）函数触发。
文件名、函数名和行号作为位置参数提供给跟踪脚本，必须使用 $arg1, $arg2, $arg3 访问：
$arg1 : (const char *) 文件名，使用  user_string($arg1) 访问
$arg2 : (const char *) 函数名，使用 user_string($arg2) 访问
$arg3 : int 行号
这个标记与 function__entry() 相反，表示Python函数的执行已经结束 (通过 return 或者异常)。 它只对纯Python (字节码) 函数触发。
参数和 function__entry() 相同
这个标记表示一个 Python 行即将被执行。它相当于用 Python 分析器逐行追踪。它不会在C函数中触发。
参数和 function__entry() 相同
当Python解释器启动一个垃圾回收循环时被触发。 arg0 是要扫描的生成器，如 gc.collect()。
当Python解释器完成一个垃圾回收循环时被触发。arg0 是收集到的对象的数量。
在 importlib 试图查找并加载模块之前被触发。arg0 是模块名称。
3.7 新版功能.
在 importlib 的 find_and_load 函数被调用后被触发 。arg0 是模块名称， arg1 表示模块是否成功加载。
3.7 新版功能.
当 sys.audit() 或 PySys_Audit() 被调用时启动。 arg0 是事件名称的 C 字符串，arg1 是一个指向元组对象的 PyObject 指针。
3.8 新版功能.
使用SystemTap集成的更高层次的方法是使用 "tapset" 。SystemTap 的等效库，它隐藏了静态标记的一些底层细节。
这里是一个基于 CPython 的非共享构建的 tapset 文件。
如果这个文件安装在 SystemTap 的 tapset 目录下（例如``/usr/share/systemtap/tapset`` ），那么这些额外的探测点就会变得可用。
这个探针点表示一个Python函数的执行已经开始。它只对纯Python （字节码）函数触发。
这个探针点是 python.function.return() 的反义操作，表示一个Python函数的执行已经结束（通过 return 或者异常）。 它只对纯Python （字节码）函数触发。
这个SystemTap脚本使用上面的tapset来更清晰地实现上面给出的跟踪Python函数调用层次结构的例子，而不需要直接命名静态标记。
下面的脚本使用上面的tapset提供了所有运行中的CPython代码的顶部视图，显示了整个系统中每一秒钟最频繁输入的前20个字节码帧。
Argument Clinic How-To
Python 常见问题
</body></doc>