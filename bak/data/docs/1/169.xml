<?xml version='1.0' encoding='utf-8'?>
<doc><id>169</id><url>https://docs.python.org/zh-cn/3/library/enum.html</url><title> --- 对枚举的支持</title><body>3.4 新版功能.
源代码： Lib/enum.py
枚举是一组符号名称（枚举成员）的集合，枚举成员应该是唯一的、不可变的。在枚举中，可以对成员进行恒等比较，并且枚举本身是可迭代的。
此模块定义了四个枚举类，它们可被用来定义名称和值的不重复集合: Enum, IntEnum, Flag 和 IntFlag。 此外还定义了一个装饰器 unique() 和一个辅助类 auto。
此基类用于创建枚举常量。 请参阅 Functional API 小节了解另一种替代性的构建语法。
此基类用于创建属于 int 的子类的枚举常量。
此基类用于创建可使用按位运算符进行组合而不会丢失其 IntFlag 成员资格的枚举常量。 IntFlag 成员同样也是 int 的子类。
此基类用于创建枚举常量 可使用按位运算符进行组合而不会丢失其 Flag 成员资格的枚举常量。
此 Enum 类装饰器可确保只将一个名称绑定到任意一个值。
实例会被替换为一个可作为 Enum 成员的适当的值。 初始值从 1 开始。
3.6 新版功能: Flag, IntFlag, auto
枚举是使用 class 语法来创建的，这使得它们易于读写。 另一种替代创建方法的描述见 Functional API。 要定义一个枚举，可以对 Enum 进行如下的子类化:
注解
Enum 的成员值
成员值可以为任意类型: int, str 等等。 如果具体的值不重要，你可以使用 auto 实例，将为你选择适当的值。 但如果你混用 auto 与其他值则需要小心谨慎。
注解
命名法
类 Color 是一个 枚举 (或称 enum)
属性 Color.RED, Color.GREEN 等等是 枚举成员 (或称 enum 成员) 并且被用作常量。
枚举成员具有 名称 和 值 (Color.RED 的名称为 RED，Color.BLUE 的值为 3 等等。)
注解
虽然我们使用 class 语法来创建 Enum，但 Enum 并不是普通的 Python 类。 更多细节请参阅 How are Enums different?。
枚举成员具有适合人类阅读的表示形式:
...而它们的 repr 包含更多信息:
一个枚举成员的 type 就是它所从属的枚举:
Enum 的成员还有一个包含其条目名称的特征属性:
枚举支持按照定义顺序进行迭代:
枚举成员是可哈希的，因此它们可在字典和集合中可用:
有时对枚举中的成员进行程序化访问是很有用的（例如在某些场合不能使用 Color.RED 因为在编程时并不知道要指定的确切颜色）。  Enum 允许这样的访问:
如果你希望通过 name 来访问枚举成员，可使用条目访问:
如果你有一个枚举成员并且需要它的 name 或 value:
不允许有同名的枚举成员:
但是，允许两个枚举成员有相同的值。 假定两个成员 A 和 B 有相同的值（且 A 先被定义），则 B 就是 A 的一个别名。 按值查找 A 和 B 的值将返回 A。 按名称查找 B 也将返回 A:
注解
试图创建具有与某个已定义的属性（另一个成员或方法等）相同名称的成员或者试图创建具有相同名称的属性也是不允许的。
默认情况下，枚举允许有多个名称作为某个相同值的别名。 如果不想要这样的行为，可以使用以下装饰器来确保每个值在枚举中只被使用一次:
专用于枚举的 class 装饰器。 它会搜索一个枚举的 __members__ 并收集所找到的任何别名；只要找到任何别名就会引发 ValueError 并附带相关细节信息:
如果确切的值不重要，你可以使用 auto:
值将由 _generate_next_value_() 来选择，该函数可以被重载:
注解
默认 _generate_next_value_() 方法的目标是提供所给出的最后一个 int 所在序列的下一个 int，但这种行为方式属于实现细节并且可能发生改变。
注解
_generate_next_value_() 方法定义必须在任何其他成员之前。
对枚举成员的迭代不会给出别名:
特殊属性 __members__ 是一个从名称到成员的只读有序映射。 它包含枚举中定义的所有名称，包括别名:
__members__ 属性可被用于对枚举成员进行详细的程序化访问。 例如，找出所有别名:
枚举成员是按标识号进行比较的:
枚举值之间的排序比较 不被 支持。 Enum 成员不属于整数 (另请参阅下文的 IntEnum):
相等比较的定义如下:
与非枚举值的比较将总是不相等（同样地，IntEnum 被显式设计成不同的行为，参见下文）:
以上示例使用整数作为枚举值。 使用整数相当简洁方便（并由 Functional API 默认提供），但并不强制要求使用。 在大部分用例中，开发者都关心枚举的实际值是什么。 但如果值 确实 重要，则枚举可以使用任意的值。
枚举属于 Python 的类，并可具有普通方法和特殊方法。 如果我们有这样一个枚举:
那么:
对于允许内容的规则如下：以单下划线开头和结尾的名称是由枚举保留而不可使用；在枚举中定义的所有其他属性将成为该枚举的成员，例外项则包括特殊方法成员 (__str__(), __add__() 等)，描述符 (方法也属于描述符) 以及在 _ignore_ 中列出的变量名。
注意：如果你的枚举定义了 __new__() 和/或 __init__() 那么指定给枚举成员的任何值都会被传入这些方法。 请参阅示例 Planet。
一个新的 Enum 类必须基于一个 Enum 类，至多一个实体数据类型以及出于实际需要的任意多个基于 object 的 mixin 类。 这些基类的顺序为:
另外，仅当一个枚举未定义任何成员时才允许子类化该枚举。 因此禁止这样的写法:
但是允许这样的写法:
允许子类化定义了成员的枚举将会导致违反类型与实例的某些重要的不可变规则。 在另一方面，允许在一组枚举之间共享某些通用行为也是有意义的。 （请参阅示例 OrderedEnum 。）
枚举可以被封存与解封:
封存的常规限制同样适用：可封存枚举必须在模块的最高层级中定义，因为解封操作要求它们可以从该模块导入。
注解
使用 pickle 协议版本 4 可以方便地封存嵌套在其他类中的枚举。
通过在枚举类中定义 __reduce_ex__() 可以对 Enum 成员的封存/解封方式进行修改。
Enum 类属于可调用对象，它提供了以下功能性 API:
该 API 的主义类似于 namedtuple。 调用 Enum 的第一个参数是枚举的名称。
第二个参数是枚举成员名称的 来源。 它可以是一个用空格分隔的名称字符串、名称序列、键/值对 2 元组的序列，或者名称到值的映射（例如字典）。 最后两种选项使得可以为枚举任意赋值；其他选项会自动以从 1 开始递增的整数赋值（使用 start 形参可指定不同的起始值）。 返回值是一个派生自 Enum 的新类。 换句话说，以上对 Animal 的赋值就等价于:
默认以 1 而以 0 作为起始数值的原因在于 0 的布尔值为 False，但所有枚举成员都应被求值为 True。
对使用功能性 API 创建的枚举执行封存可能会很麻烦，因为要使用帧堆栈的实现细节来尝试并找出枚举是在哪个模块中创建的（例如当你使用了另一个模块中的工具函数就可能失败，在 IronPython 或 Jython 上也可能无效）。 解决办法是显式地指定模块名称，如下所示:
警告
如果未提供 module，且 Enum 无法确定是哪个模块，新的 Enum 成员将不可被解封；为了让错误尽量靠近源头，封存将被禁用。
新的 pickle 协议版本 4 在某些情况下同样依赖于 __qualname__ 被设为特定位置以便 pickle 能够找到相应的类。 例如，类是否存在于全局作用域的 SomeData 类中:
完整的签名为:
将被新 Enum 类将记录为其名称的数据。
Enum 的成员。 这可以是一个空格或逗号分隔的字符串 (起始值将为 1，除非另行指定):
或是一个名称的迭代器:
或是一个 (名称, 值) 对的迭代器:
或是一个映射:
新 Enum 类所在模块的名称。
新 Enum 类在模块中的具体位置。
要加入新 Enum 类的类型。
当只传入名称时要使用的起始数值。
在 3.5 版更改: 增加了 start 形参。
所提供的第一个变种 Enum 同时也是 int 的一个子类。 IntEnum 的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较:
不过，它们仍然不可与标准 Enum 枚举进行比较:
IntEnum 值在其他方面的行为都如你预期的一样类似于整数:
所提供的下一个 Enum 的变种 IntFlag 同样是基于 int 的，不同之处在于 IntFlag 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合且结果仍然为 IntFlag 成员。 如果，正如名称所表明的，IntFlag 成员同时也是 int 的子类，并能在任何使用 int 的场合被使用。 IntFlag 成员进行除按位运算以外的其他运算都将导致失去 IntFlag 成员资格。
3.6 新版功能.
示例 IntFlag 类:
对于组合同样可以进行命名:
IntFlag 和 Enum 的另一个重要区别在于如果没有设置任何旗标（值为 0），则其布尔值为 False:
由于 IntFlag 成员同时也是 int 的子类，因此它们可以相互组合:
最后一个变种是 Flag。 与 IntFlag 类似，Flag 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合，与 IntFlag 不同的是它们不可与任何其它 Flag 枚举或 int 进行组合或比较。 虽然可以直接指定值，但推荐使用 auto 作为值以便让 Flag 选择适当的值。
3.6 新版功能.
与 IntFlag 类似，如果 Flag 成员的某种组合导致没有设置任何旗标，则其布尔值为 False:
单个旗标的值应当为二的乘方 (1, 2, 4, 8, ...)，旗标的组合则无此限制:
对 "no flags set" 条件指定一个名称并不会改变其布尔值:
注解
对于大多数新代码，强烈推荐使用 Enum 和 Flag，因为 IntEnum 和 IntFlag 打破了枚举的某些语义约定（例如可以同整数进行比较，并因而导致此行为被传递给其他无关的枚举）。 IntEnum 和 IntFlag 的使用应当仅限于 Enum 和 Flag 无法使用的场合；例如，当使用枚举替代整数常量时，或是与其他系统进行交互操作时。
虽然 IntEnum 是 enum 模块的一部分，但要独立实现也应该相当容易:
这里演示了如何定义类似的派生枚举；例如一个混合了 str 而不是 int 的 StrEnum。
几条规则：
当子类化 Enum 时，在基类序列中的混合类型必须出现于 Enum 本身之前，如以上 IntEnum 的例子所示。
虽然 Enum 可以拥有任意类型的成员，不过一旦你混合了附加类型，则所有成员必须为相应类型的值，如在上面的例子中即为 int。 此限制不适用于仅添加方法而未指定另一数据类型如 int 或 str 的混合类。
当混合了另一数据类型时，value 属性会 不同于 枚举成员自身，但它们仍保持等价且比较结果也相等。
%-style formatting:  %s 和 %r 会分别调用 Enum 类的 __str__() 和 __repr__()；其他代码 (例如表示 IntEnum 的 %i 或 %h) 会将枚举成员视为对应的混合类型。
格式化字符串字面值, str.format() 和 format() 将使用混合类型的 __format__()。 如果需要 Enum 类的 str() 或 repr()，请使用 !s 或 !r 格式代码。
当你想要定制 Enum 成员的实际值时必须使用 __new__()。 任何其他修改可以用 __new__() 也可以用 __init__()，应优先使用 __init__()。
举例来说，如果你要向构造器传入多个条目，但只希望将其中一个作为值:
虽然 Enum, IntEnum, IntFlag 和 Flag 预期可覆盖大多数应用场景，但它们无法覆盖全部。 这里有一些不同类型枚举的方案，它们可以被直接使用，或是作为自行创建的参考示例。
在许多应用场景中人们都不关心枚举的实际值是什么。 有几个方式可以定义此种类型的简单枚举：
使用 auto 的实例作为值
使用 object 的实例作为值
使用描述性的字符串作为值
使用元组作为值并用自定义的 __new__() 以一个 int 值来替代该元组
使用以上任何一种方法均可向用户指明值并不重要，并且使人能够添加、移除或重排序成员而不必改变其余成员的数值。
无论你选择何种方法，你都应当提供一个 repr() 并且它也需要隐藏（不重要的）值:
使用 auto 的形式如下:
使用 object 的形式如下:
使用字符串作为值的形式如下:
使用自动编号 __new__() 的形式如下:
注解
如果定义了 __new__() 则它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 __new__() 所替换，该方法会在类创建后被用来查找现有成员。
一个有序枚举，它不是基于 IntEnum，因此保持了正常的 Enum 不变特性（例如不可与其他枚举进行比较）:
如果发现重复的成员名称则将引发错误而不是创建别名:
注解
这个例子适用于子类化 Enum 来添加或改变禁用别名以及其他行为。 如果需要的改变只是禁用别名，也可以选择使用 unique() 装饰器。
如果定义了 __new__() 或 __init__() 则枚举成员的值将被传给这些方法:
一个演示如何使用 _ignore_ 属性的例子:
枚举具有自定义的元类，它会影响所派生枚举类及其实例（成员）的各个方面。
EnumMeta 元类负责提供 __contains__(), __dir__(), __iter__() 及其他方法以允许用户通过 Enum 类来完成一般类做不到的事情，例如 list(Color) 或 some_enum_var in Color。 EnumMeta 会负责确保最终 Enum 类中的各种其他方法是正确的 (例如 __new__(), __getnewargs__(), __str__() 和 __repr__())。
有关枚举成员最有趣的特点是它们都是单例对象。 EnumMeta 会在创建 Enum 类本身时将它们全部创建完成，然后准备好一个自定义的 __new__()，通过只返回现有的成员实例来确保不会再实例化新的对象。
__members__ 是一个 member_name:member 条目的只读有序映射。 它只在类上可用。
如果指定了 __new__()，它必须创建并返回枚举成员；相应地设定成员的 _value_ 也是一个很好的主意。 一旦所有成员都创建完成它就不会再被使用。
_name_ -- 成员的名称
_value_ -- 成员的值；可以在 __new__ 中设置 / 修改
_missing_ -- 当未发现某个值时所使用的查找函数；可被重载
_ignore_ -- 一个名称列表，可以为 list() 或 str()，它将不会被转化为成员，并会从最终类中被移除
_order_ -- 用于 Python 2/3 代码以确保成员顺序一致（类属性，在类创建期间会被移除）
_generate_next_value_ -- 用于 Functional API 并通过 auto 为枚举成员获取适当的值；可被重载
3.6 新版功能: _missing_, _order_, _generate_next_value_
3.7 新版功能: _ignore_
用来帮助 Python 2 / Python 3 代码保持同步提供 _order_ 属性。 它将与枚举的实际顺序进行对照检查，如果两者不匹配则会引发错误:
注解
在 Python 2 代码中 _order_ 属性是必须的，因为定义顺序在被记录之前就会丢失。
Enum 成员是其 Enum 类的实例，一般通过 EnumClass.member 的形式来访问。 在特定情况下它们也可通过 EnumClass.member.member 的形式来访问，但你绝对不应这样做，因为查找可能失败，或者更糟糕地返回你所查找的 Enum 成员以外的对象（这也是成员应使用全大写名称的另一个好理由）:
在 3.5 版更改.
混合了非 Enum 类型（例如 int, str 等）的 Enum 成员会按所混合类型的规则被求值；在其他情况下，所有成员都将被求值为 True。 要使你的自定义 Enum 的布尔值取决于成员的值，请在你的类中添加以下代码:
Enum 类总是会被求值为 True。
如果你为你的 Enum 子类添加了额外的方法，如同上述的 Planet 类一样，这些方法将在对成员执行 dir() 时显示出来，但对类执行时则不会显示:
如果 Flag 成员的某种组合未被命名，则 repr() 将包含所有已命名的旗标和值中所有已命名的旗标组合:
reprlib --- 另一种 repr() 实现
数字和数学模块
</body></doc>