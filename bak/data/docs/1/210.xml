<?xml version='1.0' encoding='utf-8'?>
<doc><id>210</id><url>https://docs.python.org/zh-cn/3/library/random.html</url><title> --- 生成伪随机数</title><body>源码： Lib/random.py
该模块实现了各种分布的伪随机数生成器。
对于整数，从范围中有统一的选择。 对于序列，存在随机元素的统一选择、用于生成列表的随机排列的函数、以及用于随机抽样而无需替换的函数。
在实数轴上，有计算均匀、正态（高斯）、对数正态、负指数、伽马和贝塔分布的函数。 为了生成角度分布，可以使用 von Mises 分布。
几乎所有模块函数都依赖于基本函数 random() ，它在半开放区间 [0.0,1.0) 内均匀生成随机浮点数。 Python 使用 Mersenne Twister 作为核心生成器。 它产生 53 位精度浮点数，周期为 2**19937-1 ，其在 C 中的底层实现既快又线程安全。 Mersenne Twister 是现存最广泛测试的随机数发生器之一。 但是，因为完全确定性，它不适用于所有目的，并且完全不适合加密目的。
这个模块提供的函数实际上是 random.Random 类的隐藏实例的绑定方法。 你可以实例化自己的 Random 类实例以获取不共享状态的生成器。
如果你想使用自己设计的不同基础生成器，类 Random 也可以作为子类：在这种情况下，重载 random() 、 seed() 、 getstate() 以及 setstate() 方法。可选地，新生成器可以提供 getrandbits() 方法——这允许 randrange() 在任意大的范围内产生选择。
random 模块还提供 SystemRandom 类，它使用系统函数 os.urandom() 从操作系统提供的源生成随机数。
警告
不应将此模块的伪随机生成器用于安全目的。 有关安全性或加密用途，请参阅 secrets 模块。
参见
M. Matsumoto and T. Nishimura, "Mersenne Twister: A 623-dimensionally
equidistributed uniform pseudorandom number generator", ACM Transactions on
Modeling and Computer Simulation Vol. 8, No. 1, January pp.3--30 1998.
Complementary-Multiply-with-Carry recipe 用于兼容的替代随机数发生器，具有长周期和相对简单的更新操作。
初始化随机数生成器。
如果 a 被省略或为 None ，则使用当前系统时间。 如果操作系统提供随机源，则使用它们而不是系统时间（有关可用性的详细信息，请参阅 os.urandom() 函数）。
如果 a 是 int 类型，则直接使用。
对于版本2（默认的），str 、 bytes 或 bytearray 对象转换为 int 并使用它的所有位。
对于版本1（用于从旧版本的Python再现随机序列），用于 str 和 bytes 的算法生成更窄的种子范围。
在 3.2 版更改: 已移至版本2方案，该方案使用字符串种子中的所有位。
返回捕获生成器当前内部状态的对象。 这个对象可以传递给 setstate() 来恢复状态。
state 应该是从之前调用 getstate() 获得的，并且 setstate() 将生成器的内部状态恢复到 getstate() 被调用时的状态。
返回具有 k 个随机比特位的 Python 整数。 此方法随  Mersenne Twister 生成器一起提供，其他一些生成器也可能将其作为 API 的可选部分提供。 在可能的情况下，getrandbits() 会启用 randrange() 来处理任意大的区间。
从 range(start, stop, step) 返回一个随机选择的元素。 这相当于 choice(range(start, stop, step)) ，但实际上并没有构建一个 range 对象。
位置参数模式匹配 range() 。不应使用关键字参数，因为该函数可能以意外的方式使用它们。
在 3.2 版更改: randrange() 在生成均匀分布的值方面更为复杂。 以前它使用了像``int(random()*n)``这样的形式，它可以产生稍微不均匀的分布。
返回随机整数 N 满足 a &lt;= N &lt;= b。相当于 randrange(a, b+1)。
从非空序列 seq 返回一个随机元素。 如果 seq 为空，则引发 IndexError。
从*population*中选择替换，返回大小为 k 的元素列表。 如果 population 为空，则引发 IndexError。
如果指定了 weight 序列，则根据相对权重进行选择。 或者，如果给出 cum_weights 序列，则根据累积权重（可能使用 itertools.accumulate() 计算）进行选择。 例如，相对权重``[10, 5, 30, 5]``相当于累积权重``[10, 15, 45, 50]``。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。
如果既未指定 weight 也未指定 cum_weights ，则以相等的概率进行选择。 如果提供了权重序列，则它必须与 population 序列的长度相同。 一个 TypeError 指定了 weights 和*cum_weights*。
weights 或 cum_weights 可以使用任何与 random() 所返回的 float 值互操作的数值类型（包括整数、浮点数和分数但不包括十进制小数）。 权重假定为非负数。
对于给定的种子，具有相等加权的 choices() 函数通常产生与重复调用 choice() 不同的序列。 choices() 使用的算法使用浮点运算来实现内部一致性和速度。 choice()  使用的算法默认为重复选择的整数运算，以避免因舍入误差引起的小偏差。
3.6 新版功能.
将序列 x 随机打乱位置。
可选参数 random 是一个0参数函数，在 [0.0, 1.0) 中返回随机浮点数；默认情况下，这是函数 random() 。
要改变一个不可变的序列并返回一个新的打乱列表，请使用``sample(x, k=len(x))``。
请注意，即使对于小的 len(x)，x 的排列总数也可以快速增长，大于大多数随机数生成器的周期。 这意味着长序列的大多数排列永远不会产生。 例如，长度为2080的序列是可以在 Mersenne Twister 随机数生成器的周期内拟合的最大序列。
返回从总体序列或集合中选择的唯一元素的 k 长度列表。 用于无重复的随机抽样。
返回包含来自总体的元素的新列表，同时保持原始总体不变。 结果列表按选择顺序排列，因此所有子切片也将是有效的随机样本。 这允许抽奖获奖者（样本）被划分为大奖和第二名获胜者（子切片）。
总体成员不必是 hashable 或 unique 。 如果总体包含重复，则每次出现都是样本中可能的选择。
要从一系列整数中选择样本，请使用 range() 对象作为参数。 对于从大量人群中采样，这种方法特别快速且节省空间：sample(range(10000000), k=60) 。
如果样本大小大于总体大小，则引发 ValueError 。
以下函数生成特定的实值分布。如常用数学实践中所使用的那样, 函数参数以分布方程中的相应变量命名;大多数这些方程都可以在任何统计学教材中找到。
返回 [0.0, 1.0) 范围内的下一个随机浮点数。
返回一个随机浮点数 N ，当 a &lt;= b 时 a &lt;= N &lt;= b ，当 b &lt; a 时 b &lt;= N &lt;= a 。
取决于等式 a + (b-a) * random() 中的浮点舍入，终点 b 可以包括或不包括在该范围内。
返回一个随机浮点数 N ，使得 low &lt;= N &lt;= high 并在这些边界之间使用指定的 mode 。 low 和 high 边界默认为零和一。 mode 参数默认为边界之间的中点，给出对称分布。
Beta 分布。 参数的条件是 alpha &gt; 0 和 beta &gt; 0。 返回值的范围介于 0 和 1 之间。
指数分布。 lambd 是 1.0 除以所需的平均值，它应该是非零的。 （该参数本应命名为 “lambda” ，但这是 Python 中的保留字。）如果 lambd 为正，则返回值的范围为 0 到正无穷大；如果 lambd 为负，则返回值从负无穷大到 0。
Gamma 分布。 （ 不是 gamma 函数！ ） 参数的条件是 alpha &gt; 0 和 beta &gt; 0。
概率分布函数是:
高斯分布。 mu 是平均值，sigma 是标准差。 这比下面定义的 normalvariate() 函数略快。
对数正态分布。 如果你采用这个分布的自然对数，你将得到一个正态分布，平均值为 mu 和标准差为 sigma 。 mu 可以是任何值，sigma 必须大于零。
正态分布。 mu 是平均值，sigma 是标准差。
冯·米塞斯（von Mises）分布。 mu 是平均角度，以弧度表示，介于0和 2*pi 之间，kappa 是浓度参数，必须大于或等于零。 如果 kappa 等于零，则该分布在 0 到 2*pi 的范围内减小到均匀的随机角度。
帕累托分布。 alpha 是形状参数。
威布尔分布。 alpha 是比例参数，beta 是形状参数。
。该类实现了 random 模块所用的默认伪随机数生成器。
使用 os.urandom() 函数的类，用从操作系统提供的源生成随机数。 这并非适用于所有系统。 也不依赖于软件状态，序列不可重现。 因此，seed() 方法没有效果而被忽略。 getstate() 和 setstate() 方法如果被调用则引发 NotImplementedError。
有时能够重现伪随机数生成器给出的序列是有用的。 通过重新使用种子值，只要多个线程没有运行，相同的序列就可以在两次不同运行之间重现。
大多数随机模块的算法和种子函数都会在 Python 版本中发生变化，但保证两个方面不会改变：
如果添加了新的播种方法，则将提供向后兼容的播种机。
当兼容的播种机被赋予相同的种子时，生成器的 random() 方法将继续产生相同的序列。
基本示例:
模拟:
statistical bootstrapping 的示例，使用重新采样和替换来估计一个样本的均值的置信区间:
使用 重新采样排列测试 来确定统计学显著性或者使用  p-值 来观察药物与安慰剂的作用之间差异的示例:
多服务器队列的到达时间和服务交付模拟:
参见
Statistics for Hackers Jake Vanderplas 撰写的视频教程，使用一些基本概念进行统计分析，包括模拟、抽样、改组和交叉验证。
Economics Simulation Peter Norvig 编写的市场模拟，显示了该模块提供的许多工具和分布的有效使用（高斯、均匀、样本、beta变量、选择、三角和随机范围等）。
A Concrete Introduction to Probability (using Python) Peter Norvig 撰写的教程，涵盖了概率论基础知识，如何编写模拟，以及如何使用 Python 进行数据分析。
fractions --- 分数
statistics --- 数学统计函数
</body></doc>