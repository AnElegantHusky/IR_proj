<?xml version='1.0' encoding='utf-8'?>
<doc><id>153</id><url>https://docs.python.org/zh-cn/3/library/multiprocessing.shared_memory.html</url><title> --- 可从进程直接访问的共享内存</title><body>源代码: Lib/multiprocessing/shared_memory.py
3.8 新版功能.
该模块提供了一个 SharedMemory 类，用于分配和管理多核或对称多处理器（SMP）机器上进程间的共享内存。为了协助管理不同进程间的共享内存生命周期，multiprocessing.managers 模块也提供了一个 BaseManager 的子类： SharedMemoryManager。
本模块中，共享内存是指 "System V 类型" 的共享内存块（虽然可能和它实现方式不完全一致）而不是 “分布式共享内存”。这种类型的的共享内存允许不同进程读写一片公共（或者共享）的易失性存储区域。一般来说，进程被限制只能访问属于自己进程空间的内存，但是共享内存允许跨进成共享数据，从而避免通过进程间发送消息的形式传递数据。相比通过磁盘、套接字或者其他要求序列化、反序列化和复制数据的共享形式，直接通过内存共享数据拥有更出色性能。
创建一个新的共享内存块或者连接到一片已经存在的共享内存块。每个共享内存块都被指定了一个全局唯一的名称。通过这种方式，一个进程可以通过提供一个特定的名字创建一个共享内存区块，然后其他进程使用同样的名字连接到这个共享内存块。
作为一种跨进成共享数据的方式，共享内存块的寿命可能超过创建它的原始进程。一个共享内存块可能同时被多个进程使用，当一个进程不再需要访问这个共享内存块的时候，应该调用 close()  方法。当一个共享内存块不被任何进程使用的时候，应该调用 unlink()  方法以执行必要的清理。
name 是共享内存的唯一名称，字符串类型。如果创建一个新共享内存块的时候，名称指定为 None  (默认值)，将会随机产生一个新名称。
create 指定创建一个新的共享内存块 (True) 还是连接到已存在的共享内存块 (False) 。
如果是新创建共享内存块则 size 用于指定块的大小为多少字节。由于某些平台是使用特定内存页大小为最小单位来分配的，最终得到的内存块大小可能大于或等于要求的大小。如果是连接到已经存在的共享内存块， size 参数会被忽略。
关闭实例对于共享内存的访问连接。所有实例确认自己不再需要使用共享内存的时候都应该调用 close() ，以保证必要的资源清理。调用 close() 并不会销毁共享内存区域。
请求销毁底层的共享内存块。为了执行必要的资源清理， 在所有使用这个共享内存块的进程中， unlink() 应该调用一次(且只能调用一次) 。发出此销毁请求后，共享内存块可能会、也可能不会立即销毁，且此行为在不同操作系统之间可能不同。调用 unlink() 后再尝试方位其中的数据可能导致内存错误。注意: 最后一个关闭共享内存访问权限的进程可以以任意顺序调用 unlink() 和 close() 。
共享内存块内容的 memoryview 。
共享内存块的唯一标识，只读属性。
共享内存块的字节大小，只读属性
以下示例展示了 SharedMemory 的底层的用法:
以下示例展示了一个现实中的例子，使用  SharedMemory 类和`NumPy arrays &lt;https://www.numpy.org/&gt;`_ 结合, 从两个 Python shell 中访问同一个 numpy.ndarray :
BaseManager 的子类，可用于管理跨进程的共享内存块。
调用 SharedMemoryManager  实例上的 start()  方法会启动一个新进程。这个新进程的唯一目的就是管理所有由它创建的共享内存块的生命周期。想要释放此进程管理的所有共享内存块，可以调用实例的 shutdown()  方法。这会触发执行它管理的所有  SharedMemory 对象的 SharedMemory.unlink() 方法，然后停止这个进程。通过  SharedMemoryManager 创建 SharedMemory 实例，我们可以避免手动跟踪和释放共享内存资源。
这个类提供了创建和返回 SharedMemory 实例的方法，以及以共享内存为基础创建一个列表类对象 (ShareableList) 的方法。
有关继承的可选输入参数 address 和 authkey  以及他们如何用于从进程连接已经存在的 SharedMemoryManager 服务，参见 multiprocessing.managers.BaseManager
使用 size 参数，创建一个新的指定字节大小的 SharedMemory 对象并返回。
创建并返回一个新的 ShareableList 对象，通过输入参数 sequence 初始化。
下面的案例展示了 SharedMemoryManager 的基础机制:
以下案例展示了 SharedMemoryManager 对象的一种可能更方便的使用方式，通过 with 语句来保证所有共享内存块在使用完后被释放。
当在 with 语句中使用 SharedMemoryManager  对象的时候，使用这个管理器创建的共享内存块会在  with 语句代码块结束后被释放。
提供一个可修改的类 list 对象，其中所有值都存放在共享内存块中。这限制了可被存储在其中的值只能是 int, float, bool, str  （每条数据小于10M）, bytes （每条数据小于10M）以及 None 这些内置类型。它另一个显著区别于内置 list 类型的地方在于它的长度无法修改（比如，没有 append, insert 等操作）且不支持通过切片操作动态创建新的 ShareableList  实例。
sequence 会被用来为一个新的 ShareableList 填充值。 设为 None 则会基于共享内存名称关联到一个已经存在的 ShareableList。
name 是所请求的共享内存的唯一名称，与 SharedMemory 的定义中所描述的一致。 当关联到现有的 ShareableList 时，则指明其共享内存块的唯一名称并将 sequence 设为 None。
返回 value 出现的次数。
返回 value 首次出现的位置，如果 value 不存在, 则抛出 ValueError 异常。
包含由所有当前存储值所使用的 struct 打包格式的只读属性。
存储了值的 SharedMemory 实例。
下面的例子演示了 ShareableList 实例的基本用法:
下面的例子演示了一个、两个或多个进程如何通过提供下层的共享内存块名称来访问同一个 ShareableList:
multiprocessing --- 基于进程的并行
concurrent 包
</body></doc>