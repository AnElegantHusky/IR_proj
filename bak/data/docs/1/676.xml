<?xml version='1.0' encoding='utf-8'?>
<doc><id>676</id><url>https://docs.python.org/zh-cn/3/library/asyncio-sync.html</url><title>Synchronization Primitives</title><body>Source code: Lib/asyncio/locks.py
asyncio synchronization primitives are designed to be similar to
those of the threading module with two important caveats:
asyncio primitives are not thread-safe, therefore they should not
be used for OS thread synchronization (use threading for
that);
methods of these synchronization primitives do not accept the timeout
argument; use the asyncio.wait_for() function to perform
operations with timeouts.
asyncio has the following basic synchronization primitives:
Lock
Event
Condition
Semaphore
BoundedSemaphore
Implements a mutex lock for asyncio tasks.  Not thread-safe.
An asyncio lock can be used to guarantee exclusive access to a
shared resource.
The preferred way to use a Lock is an async with
statement:
which is equivalent to:
Deprecated since version 3.8, will be removed in version 3.10: loop 形参。
Acquire the lock.
This method waits until the lock is unlocked, sets it to
locked and returns True.
When more than one coroutine is blocked in acquire()
waiting for the lock to be unlocked, only one coroutine
eventually proceeds.
Acquiring a lock is fair: the coroutine that proceeds will be
the first coroutine that started waiting on the lock.
Release the lock.
When the lock is locked, reset it to unlocked and return.
If the lock is unlocked, a RuntimeError is raised.
Return True if the lock is locked.
An event object.  Not thread-safe.
An asyncio event can be used to notify multiple asyncio tasks
that some event has happened.
An Event object manages an internal flag that can be set to true
with the set() method and reset to false with the
clear() method.  The wait() method blocks until the
flag is set to true.  The flag is set to false initially.
Deprecated since version 3.8, will be removed in version 3.10: loop 形参。
示例:
Wait until the event is set.
If the event is set, return True immediately.
Otherwise block until another task calls set().
Set the event.
All tasks waiting for event to be set will be immediately
awakened.
Clear (unset) the event.
Tasks awaiting on wait() will now block until the
set() method is called again.
Return True if the event is set.
A Condition object.  Not thread-safe.
An asyncio condition primitive can be used by a task to wait for
some event to happen and then get exclusive access to a shared
resource.
In essence, a Condition object combines the functionality
of an Event and a Lock.  It is possible to have
multiple Condition objects share one Lock, which allows coordinating
exclusive access to a shared resource between different tasks
interested in particular states of that shared resource.
The optional lock argument must be a Lock object or
None.  In the latter case a new Lock object is created
automatically.
Deprecated since version 3.8, will be removed in version 3.10: loop 形参。
The preferred way to use a Condition is an async with
statement:
which is equivalent to:
Acquire the underlying lock.
This method waits until the underlying lock is unlocked,
sets it to locked and returns True.
Wake up at most n tasks (1 by default) waiting on this
condition.  The method is no-op if no tasks are waiting.
The lock must be acquired before this method is called and
released shortly after.  If called with an unlocked lock
a RuntimeError error is raised.
Return True if the underlying lock is acquired.
Wake up all tasks waiting on this condition.
This method acts like notify(), but wakes up all waiting
tasks.
The lock must be acquired before this method is called and
released shortly after.  If called with an unlocked lock
a RuntimeError error is raised.
Release the underlying lock.
在未锁定的锁调用时，会引发 RuntimeError 异常。
Wait until notified.
If the calling task has not acquired the lock when this method is
called, a RuntimeError is raised.
This method releases the underlying lock, and then blocks until
it is awakened by a notify() or notify_all() call.
Once awakened, the Condition re-acquires its lock and this method
returns True.
Wait until a predicate becomes true.
The predicate must be a callable which result will be
interpreted as a boolean value.  The final value is the
return value.
A Semaphore object.  Not thread-safe.
A semaphore manages an internal counter which is decremented by each
acquire() call and incremented by each release() call.
The counter can never go below zero; when acquire() finds
that it is zero, it blocks, waiting until some task calls
release().
The optional value argument gives the initial value for the
internal counter (1 by default). If the given value is
less than 0 a ValueError is raised.
Deprecated since version 3.8, will be removed in version 3.10: loop 形参。
The preferred way to use a Semaphore is an async with
statement:
which is equivalent to:
获取一个信号量。
If the internal counter is greater than zero, decrement
it by one and return True immediately.  If it is zero, wait
until a release() is called and return True.
Returns True if semaphore can not be acquired immediately.
Release a semaphore, incrementing the internal counter by one.
Can wake up a task waiting to acquire the semaphore.
Unlike BoundedSemaphore, Semaphore allows
making more release() calls than acquire() calls.
A bounded semaphore object.  Not thread-safe.
Bounded Semaphore is a version of Semaphore that raises
a ValueError in release() if it
increases the internal counter above the initial value.
Deprecated since version 3.8, will be removed in version 3.10: loop 形参。
3.7 版后已移除: Acquiring a lock using await lock or yield from lock and/or
with statement (with await lock, with (yield from
lock)) is deprecated.  Use async with lock instead.
流
子进程集
</body></doc>