<?xml version='1.0' encoding='utf-8'?>
<doc><id>419</id><url>https://docs.python.org/zh-cn/3/c-api/buffer.html</url><title>缓冲协议</title><body>在 Python 中可使用一些对象来包装对底层内存数组或称 缓冲 的访问。此类对象包括内置的 bytes 和 bytearray 以及一些如 array.array 这样的扩展类型。第三方库也可能会为了特殊的目的而定义它们自己的类型，例如用于图像处理和数值分析等。
虽然这些类型中的每一种都有自己的语义，但它们具有由可能较大的内存缓冲区支持的共同特征。 在某些情况下，希望直接访问该缓冲区而无需中间复制。
Python 以 缓冲协议 的形式在 C 层级上提供这样的功能。 此协议包括两个方面:
在生产者这一方面，该类型的协议可以导出一个“缓冲区接口”，允许公开它的底层缓冲区信息。该接口的描述信息在 Buffer Object Structures 一节中；
在消费者一侧，有几种方法可用于获得指向对象的原始底层数据的指针（例如一个方法的形参）。
一些简单的对象例如 bytes 和 bytearray 会以面向字节的形式公开它们的底层缓冲区。 也可能会用其他形式；例如 array.array 所公开的元素可以是多字节值。
缓冲区接口的消费者的一个例子是文件对象的 write() 方法：任何可以输出为一系列字节流的对象可以被写入文件。然而 write() 方法只需要对于传入对象的只读权限，其他的方法，如 readinto() 需要参数内容的写入权限。缓冲区接口使得对象可以选择性地允许或拒绝读写或只读缓冲区的导出。
对于缓冲区接口的使用者而言，有两种方式来获取一个目的对象的缓冲：
使用正确的参数来调用 PyObject_GetBuffer() 函数；
调用 PyArg_ParseTuple() (或其同级对象之一) 并传入 y*, w* or s* 格式代码 中的一个。
在这两种情况下，当不再需要缓冲区时必须调用 PyBuffer_Release() 。如果此操作失败，可能会导致各种问题，例如资源泄漏。
缓冲区结构(或者简单地称为“buffers”)对于将二进制数据从另一个对象公开给 Python 程序员非常有用。它们还可以用作零拷贝切片机制。使用它们引用内存块的能力，可以很容易地将任何数据公开给 Python 程序员。内存可以是 C 扩展中的一个大的常量数组，也可以是在传递到操作系统库之前用于操作的原始内存块，或者可以用来传递本机内存格式的结构化数据。
与 Python 解释器公开的大多部数据类型不同，缓冲区不是 PyObject 指针而是简单的 C 结构。 这使得它们可以非常简单地创建和复制。 当需要为缓冲区加上泛型包装器时，可以创建一个 内存视图 对象。
有关如何编写并导出对象的简短说明，请参阅 缓冲区对象结构。 要获取缓冲区对象，请参阅 PyObject_GetBuffer()。
指向由缓冲区字段描述的逻辑结构开始的指针。 这可以是导出程序底层物理内存块中的任何位置。 例如，使用负的 strides 值可能指向内存块的末尾。
对于 contiguous ，‘邻接’数组，值指向内存块的开头。
对导出对象的新引用。 该引用归使用者所有，并由 PyBuffer_Release() 自动递减并设置为 NULL。 该字段等于任何标准 C-API 函数的返回值。
作为一种特殊情况，对于由 PyMemoryView_FromBuffer() 或 PyBuffer_FillInfo() 包装的 temporary 缓冲区，此字段为 NULL。 通常，导出对象不得使用此方案。
product(shape) * itemsize。对于连续数组，这是基础内存块的长度。对于非连续数组，如果逻辑结构复制到连续表示形式，则该长度将具有该长度。
仅当缓冲区是通过保证连续性的请求获取时，才访问 ((char *)buf)[0] up to ((char *)buf)[len-1] 时才有效。在大多数情况下，此类请求将为 PyBUF_SIMPLE 或 PyBUF_WRITABLE。
缓冲区是否为只读的指示器。此字段由 PyBUF_WRITABLE 标志控制。
单个元素的项大小（以字节为单位）。与 struct.calcsize() 调用非 NULL format 的值相同。
重要例外：如果使用者请求的缓冲区没有 PyBUF_FORMAT 标志，format 将设置为 NULL，但 itemsize 仍具有原始格式的值。
如果 shape 存在，则相等的 product(shape) * itemsize == len 仍然存在，使用者可以使用 itemsize 来导航缓冲区。
如果 shape 是 NULL，因为结果为 PyBUF_SIMPLE 或 PyBUF_WRITABLE 请求，则使用者必须忽略 itemsize，并假设 itemsize == 1。
在 struct 模块样式语法中 NUL 字符串，描述单个项的内容。如果这是 NULL，则假定为``"B"`` (无符号字节) 。
此字段由 PyBUF_FORMAT 标志控制。
The number of dimensions the memory represents as an n-dimensional array.
If it is 0, buf points to a single item representing
a scalar. In this case, shape, strides
and suboffsets MUST be NULL.
The macro PyBUF_MAX_NDIM limits the maximum number of dimensions
to 64. Exporters MUST respect this limit, consumers of multi-dimensional
buffers SHOULD be able to handle up to PyBUF_MAX_NDIM dimensions.
An array of Py_ssize_t of length ndim
indicating the shape of the memory as an n-dimensional array. Note that
shape[0] * ... * shape[ndim-1] * itemsize MUST be equal to
len.
Shape值被限定在 shape[n] &gt;= 0 。 shape[n] == 0 这一情形需要特别注意。查看 complex arrays 来获得更多的信息。
shape数组对于使用者来说是只读的。
An array of Py_ssize_t of length ndim
giving the number of bytes to skip to get to a new element in each
dimension.
Stride 步幅数组中的值可以为任何整数。对于常规数组，步幅通常为正数，但是使用者必须能够处理 strides[n] &lt;= 0 的情况。更多信息请参阅 complex arrays 。
The strides array is read-only for the consumer.
An array of Py_ssize_t of length ndim.
If suboffsets[n] &gt;= 0, the values stored along the nth dimension are
pointers and the suboffset value dictates how many bytes to add to each
pointer after de-referencing. A suboffset value that is negative
indicates that no de-referencing should occur (striding in a contiguous
memory block).
If all suboffsets are negative (i.e. no de-referencing is needed), then
this field must be NULL (the default value).
Python Imaging Library (PIL) 中使用了这种数组的表达方式。请参阅 complex arrays 来了解如何从这样一个数组中访问元素。
suboffsets 数组对于使用者来说是只读的。
This is for use internally by the exporting object. For example, this
might be re-cast as an integer by the exporter and used to store flags
about whether or not the shape, strides, and suboffsets arrays must be
freed when the buffer is released. The consumer MUST NOT alter this
value.
Buffers are usually obtained by sending a buffer request to an exporting
object via PyObject_GetBuffer(). Since the complexity of the logical
structure of the memory can vary drastically, the consumer uses the flags
argument to specify the exact buffer type it can handle.
All Py_buffer fields are unambiguously defined by the request
type.
The following fields are not influenced by flags and must always be filled in
with the correct values: obj, buf,
len, itemsize, ndim.
Controls the readonly field. If set, the exporter
MUST provide a writable buffer or else report failure. Otherwise, the
exporter MAY provide either a read-only or writable buffer, but the choice
MUST be consistent for all consumers.
Controls the format field. If set, this field MUST
be filled in correctly. Otherwise, this field MUST be NULL.
PyBUF_WRITABLE can be |'d to any of the flags in the next section.
Since PyBUF_SIMPLE is defined as 0, PyBUF_WRITABLE
can be used as a stand-alone flag to request a simple writable buffer.
PyBUF_FORMAT can be |'d to any of the flags except PyBUF_SIMPLE.
The latter already implies format B (unsigned bytes).
The flags that control the logical structure of the memory are listed
in decreasing order of complexity. Note that each flag contains all bits
of the flags below it.
请求
形状
步幅
子偏移量
是
是
如果需要的话
是
是
NULL
是
NULL
NULL
NULL
NULL
NULL
C or Fortran contiguity can be explicitly requested,
with and without stride information. Without stride information, the buffer
must be C-contiguous.
请求
形状
步幅
子偏移量
邻接
是
是
NULL
C
是
是
NULL
F
是
是
NULL
C 或 F
是
NULL
NULL
C
所有可能的请求都由上一节中某些标志的组合完全定义。为方便起见，缓冲区协议提供常用的组合作为单个标志。
In the following table U stands for undefined contiguity. The consumer would
have to call PyBuffer_IsContiguous() to determine contiguity.
请求
形状
步幅
子偏移量
邻接
只读
format
是
是
如果需要的话
U
0
是
是
是
如果需要的话
U
1 或 0
是
是
是
NULL
U
0
是
是
是
NULL
U
1 或 0
是
是
是
NULL
U
0
NULL
是
是
NULL
U
1 或 0
NULL
是
NULL
NULL
C
0
NULL
是
NULL
NULL
C
1 或 0
NULL
The logical structure of NumPy-style arrays is defined by itemsize,
ndim, shape and strides.
If ndim == 0, the memory location pointed to by buf is
interpreted as a scalar of size itemsize. In that case,
both shape and strides are NULL.
If strides is NULL, the array is interpreted as
a standard n-dimensional C-array. Otherwise, the consumer must access an
n-dimensional array as follows:
As noted above, buf can point to any location within
the actual memory block. An exporter can check the validity of a buffer with
this function:
In addition to the regular items, PIL-style arrays can contain pointers
that must be followed in order to get to the next element in a dimension.
For example, the regular three-dimensional C-array char v[2][2][3] can
also be viewed as an array of 2 pointers to 2 two-dimensional arrays:
char (*v[2])[2][3]. In suboffsets representation, those two pointers
can be embedded at the start of buf, pointing
to two char x[2][3] arrays that can be located anywhere in memory.
Here is a function that returns a pointer to the element in an N-D array
pointed to by an N-dimensional index when there are both non-NULL strides
and suboffsets:
Return 1 if obj supports the buffer interface otherwise 0.  When 1 is
returned, it doesn't guarantee that PyObject_GetBuffer() will
succeed.  This function always succeeds.
Send a request to exporter to fill in view as specified by  flags.
If the exporter cannot provide a buffer of the exact type, it MUST raise
PyExc_BufferError, set view-&gt;obj to NULL and
return -1.
On success, fill in view, set view-&gt;obj to a new reference
to exporter and return 0. In the case of chained buffer providers
that redirect requests to a single object, view-&gt;obj MAY
refer to this object instead of exporter (See Buffer Object Structures).
Successful calls to PyObject_GetBuffer() must be paired with calls
to PyBuffer_Release(), similar to malloc() and free().
Thus, after the consumer is done with the buffer, PyBuffer_Release()
must be called exactly once.
Release the buffer view and decrement the reference count for
view-&gt;obj. This function MUST be called when the buffer
is no longer being used, otherwise reference leaks may occur.
It is an error to call this function on a buffer that was not obtained via
PyObject_GetBuffer().
Return the implied itemsize from format.
This function is not yet implemented.
Return 1 if the memory defined by the view is C-style (order is
'C') or Fortran-style (order is 'F') contiguous or either one
(order is 'A').  Return 0 otherwise.  This function always succeeds.
Get the memory area pointed to by the indices inside the given view.
indices must point to an array of view-&gt;ndim indices.
Copy contiguous len bytes from buf to view.
fort can be 'C' or 'F' (for C-style or Fortran-style ordering).
0 is returned on success, -1 on error.
Copy len bytes from src to its contiguous representation in buf.
order can be 'C' or 'F' or 'A' (for C-style or Fortran-style
ordering or either one). 0 is returned on success, -1 on error.
This function fails if len != src-&gt;len.
Fill the strides array with byte-strides of a contiguous (C-style if
order is 'C' or Fortran-style if order is 'F') array of the
given shape with the given number of bytes per element.
Handle buffer requests for an exporter that wants to expose buf of size len
with writability set according to readonly. buf is interpreted as a sequence
of unsigned bytes.
The flags argument indicates the request type. This function always fills in
view as specified by flags, unless buf has been designated as read-only
and PyBUF_WRITABLE is set in flags.
On success, set view-&gt;obj to a new reference to exporter and
return 0. Otherwise, raise PyExc_BufferError, set
view-&gt;obj to NULL and return -1;
如果此函数用作 getbufferproc 的一部分，则 exporter 必须设置为导出对象，并且必须在未修改的情况下传递 flags。否则，exporter 必须是 NULL。
迭代器协议
旧缓冲协议
</body></doc>