<?xml version='1.0' encoding='utf-8'?>
<doc><id>494</id><url>https://docs.python.org/zh-cn/3/library/contextlib.html</url><title> --- 为 </title><body>源代码 Lib/contextlib.py
此模块为涉及 with 语句的常见任务提供了实用的程序。更多信息请参见 上下文管理器类型 和 with 语句上下文管理器。
提供的函数和类：
一个为实现了 object.__aenter__() 与 object.__aexit__() 的类提供的 abstract base class。 为 object.__aenter__() 提供的一个默认实现是返回 self 而 object.__aexit__() 是一个默认返回 None 的抽象方法。 参见 异步上下文管理器 的定义。
3.6 新版功能.
一个为实现了 object.__aenter__() 与 object.__aexit__() 的类提供的 abstract base class。 为 object.__aenter__() 提供的一个默认实现是返回 self 而 object.__aexit__() 是一个默认返回 None 的抽象方法。 参见 异步上下文管理器 的定义。
3.7 新版功能.
这个函数是一个 decorator ，它可以定义一个支持 with 语句上下文的工厂函数， 而不需要创建一个类或区 __enter__() 与 __exit__() 方法。
尽管许多对象原生支持使用 with 语句，但有些需要被管理的资源并不是上下文管理器，并且没有实现 close() 方法而不能使用 contextlib.closing 。
下面是一个抽象的示例，展示如何确保正确的资源管理：
被装饰的函数在被调用时，必须返回一个 generator-iterator。这个迭代器必须只 yield 一个值出来，这个值会被用在 with 语句中，绑定到 as 后面的变量，如果给定了的话。
当生成器发生 yield 时，嵌套在 with 语句中的语句体会被执行。 语句体执行完毕离开之后，该生成器将被恢复执行。 如果在该语句体中发生了未处理的异常，则该异常会在生成器发生 yield 时重新被引发。 因此，你可以使用 try...except...finally 语句来捕获该异常（如果有的话），或确保进行了一些清理。 如果仅出于记录日志或执行某些操作（而非完全抑制异常）的目的捕获了异常，生成器必须重新引发该异常。 否则生成器的上下文管理器将向 with 语句指示该异常已经被处理，程序将立即在 with 语句之后恢复并继续执行。
contextmanager() 使用 ContextDecorator 因此它创建的上下文管理器不仅可以用在 with 语句中，还可以用作一个装饰器。当它用作一个装饰器时，每一次函数调用时都会隐式创建一个新的生成器实例（这使得 contextmanager() 创建的上下文管理器满足了支持多次调用以用作装饰器的需求，而非“一次性”的上下文管理器）。
在 3.2 版更改: ContextDecorator 的使用。
与 contextmanager() 类似，但创建的是一个 异步上下文管理器。
这个函数是一个 decorator ，它可以定义一个支持 async with 语句的异步上下文管理器的工厂函数， 而不需要创建一个类或区分 __aenter__() 与 __aexit__() 方法。它必须被作用在一个 asynchronous generator 函数上
一个简单的示例：
3.7 新版功能.
返回一个在语句块执行完成时关闭 things 的上下文管理器。这基本上等价于
并允许你编写这样的代码
而无需显式地关闭 page 。 即使发生错误，在退出 with 语句块时， page.close() 也同样会被调用。
返回一个从 __enter__ 返回 enter_result 的上下文管理器，除此之外不执行任何操作。它旨在用于可选上下文管理器的一种替代，例如：:
一个使用 enter_result 的例子：
3.7 新版功能.
返回一个上下文管理器，如果任何一个指定的异常发生在使用该上下文管理器的 with 语句中，该异常将被它抑制，然后程序将从 with 语句结束后的第一个语句开始恢复执行。
与完全抑制异常的任何其他机制一样，该上下文管理器应当只用来抑制非常具体的错误，并确保该场景下静默地继续执行程序是通用的正确做法。
例如
这段代码等价于：
该上下文管理器是 reentrant 。
3.4 新版功能.
用于将 sys.stdout 临时重定向到一个文件或类文件对象的上下文管理器。
该工具给已有的将输出硬编码写到 stdout 的函数或类提供了额外的灵活性。
例如， help() 通常把输出写到 sys.stdout 。你可以通过重定向到一个 io.StringIO 来捕获该输出到一个字符串中。
如果要把 help() 的输出写到磁盘上的一个文件，重定向该输出到一个常规文件：
如果要把 help() 的输出写到 sys.stderr ：
需要注意的点在于， sys.stdout 的全局副作用意味着此上下文管理器不适合在库代码和大多数多线程应用程序中使用。它对子进程的输出没有影响。不过对于许多工具脚本而言，它仍然是一个有用的方法。
该上下文管理器是 reentrant 。
3.4 新版功能.
与 redirect_stdout() 类似，不过是将 sys.stderr 重定向到一个文件或类文件对象。
该上下文管理器是 reentrant 。
3.5 新版功能.
一个使上下文管理器能用作装饰器的基类。
与往常一样，继承自 ContextDecorator  的上下文管理器必须实现 __enter__ 与 __exit__ 。即使用作装饰器， __exit__ 依旧会保持可能的异常处理。
ContextDecorator 被用在 contextmanager() 中，因此你自然获得了这项功能。
ContextDecorator 的示例:
这个改动只是针对如下形式的一个语法糖：
ContextDecorator 使得你可以这样改写：
这能清楚地表明， cm 作用于整个函数，而不仅仅是函数的一部分（同时也能保持不错的缩进层级）。
现有的上下文管理器即使已经有基类，也可以使用 ContextDecorator 作为混合类进行扩展：
注解
由于被装饰的函数必须能够被多次调用，因此对应的上下文管理器必须支持在多个 with 语句中使用。如果不是这样，则应当使用原来的具有显式 with 语句的形式使用该上下文管理器。
3.2 新版功能.
该上下文管理器的设计目标是使得在编码中组合其他上下文管理器和清理函数更加容易，尤其是那些可选的或由输入数据驱动的上下文管理器。
例如，通过一个如下的 with 语句可以很容易处理一组文件：
每个实例维护一个注册了一组回调的栈，这些回调在实例关闭时以相反的顺序被调用（显式或隐式地在 with 语句的末尾）。请注意，当一个栈实例被垃圾回收时，这些回调将 不会 被隐式调用。
通过使用这个基于栈的模型，那些通过 __init__ 方法获取资源的上下文管理器（如文件对象）能够被正确处理。
由于注册的回调函数是按照与注册相反的顺序调用的，因此最终的行为就像多个嵌套的 with 语句用在这些注册的回调函数上。这个行为甚至扩展到了异常处理：如果内部的回调函数抑制或替换了异常，则外部回调收到的参数是基于该更新后的状态得到的。
这是一个相对底层的 API，它负责正确处理栈里回调退出时依次展开的细节。它为相对高层的上下文管理器提供了一个合适的基础，使得它能根据应用程序的需求使用特定方式操作栈。
3.3 新版功能.
Enters a new context manager and adds its __exit__() method to
the callback stack. The return value is the result of the context
manager's own __enter__() method.
These context managers may suppress exceptions just as they normally
would if used directly as part of a with statement.
Adds a context manager's __exit__() method to the callback stack.
As __enter__ is not invoked, this method can be used to cover
part of an __enter__() implementation with a context manager's own
__exit__() method.
If passed an object that is not a context manager, this method assumes
it is a callback with the same signature as a context manager's
__exit__() method and adds it directly to the callback stack.
By returning true values, these callbacks can suppress exceptions the
same way context manager __exit__() methods can.
The passed in object is returned from the function, allowing this
method to be used as a function decorator.
Accepts an arbitrary callback function and arguments and adds it to
the callback stack.
Unlike the other methods, callbacks added this way cannot suppress
exceptions (as they are never passed the exception details).
The passed in callback is returned from the function, allowing this
method to be used as a function decorator.
Transfers the callback stack to a fresh ExitStack instance
and returns it. No callbacks are invoked by this operation - instead,
they will now be invoked when the new stack is closed (either
explicitly or implicitly at the end of a with statement).
For example, a group of files can be opened as an "all or nothing"
operation as follows:
Immediately unwinds the callback stack, invoking callbacks in the
reverse order of registration. For any context managers and exit
callbacks registered, the arguments passed in will indicate that no
exception occurred.
An asynchronous context manager, similar
to ExitStack, that supports combining both synchronous and
asynchronous context managers, as well as having coroutines for
cleanup logic.
The close() method is not implemented, aclose() must be used
instead.
Similar to enter_context() but expects an asynchronous context
manager.
Similar to push() but expects either an asynchronous context manager
or a coroutine function.
Similar to callback() but expects a coroutine function.
Similar to close() but properly handles awaitables.
Continuing the example for asynccontextmanager():
3.7 新版功能.
This section describes some examples and recipes for making effective use of
the tools provided by contextlib.
The primary use case for ExitStack is the one given in the class
documentation: supporting a variable number of context managers and other
cleanup operations in a single with statement. The variability
may come from the number of context managers needed being driven by user
input (such as opening a user specified collection of files), or from
some of the context managers being optional:
As shown, ExitStack also makes it quite easy to use with
statements to manage arbitrary resources that don't natively support the
context management protocol.
It is occasionally desirable to catch exceptions from an __enter__
method implementation, without inadvertently catching exceptions from
the with statement body or the context manager's __exit__
method. By using ExitStack the steps in the context management
protocol can be separated slightly in order to allow this:
Actually needing to do this is likely to indicate that the underlying API
should be providing a direct resource management interface for use with
try/except/finally statements, but not
all APIs are well designed in that regard. When a context manager is the
only resource management API provided, then ExitStack can make it
easier to handle various situations that can't be handled directly in a
with statement.
As noted in the documentation of ExitStack.push(), this
method can be useful in cleaning up an already allocated resource if later
steps in the __enter__() implementation fail.
Here's an example of doing this for a context manager that accepts resource
acquisition and release functions, along with an optional validation function,
and maps them to the context management protocol:
A pattern you will sometimes see is a try-finally statement with a flag
variable to indicate whether or not the body of the finally clause should
be executed. In its simplest form (that can't already be handled just by
using an except clause instead), it looks something like this:
As with any try statement based code, this can cause problems for
development and review, because the setup code and the cleanup code can end
up being separated by arbitrarily long sections of code.
ExitStack makes it possible to instead register a callback for
execution at the end of a with statement, and then later decide to skip
executing that callback:
This allows the intended cleanup up behaviour to be made explicit up front,
rather than requiring a separate flag variable.
If a particular application uses this pattern a lot, it can be simplified
even further by means of a small helper class:
If the resource cleanup isn't already neatly bundled into a standalone
function, then it is still possible to use the decorator form of
ExitStack.callback() to declare the resource cleanup in
advance:
Due to the way the decorator protocol works, a callback function
declared this way cannot take any parameters. Instead, any resources to
be released must be accessed as closure variables.
ContextDecorator makes it possible to use a context manager in
both an ordinary with statement and also as a function decorator.
For example, it is sometimes useful to wrap functions or groups of statements
with a logger that can track the time of entry and time of exit.  Rather than
writing both a function decorator and a context manager for the task,
inheriting from ContextDecorator provides both capabilities in a
single definition:
Instances of this class can be used as both a context manager:
And also as a function decorator:
Note that there is one additional limitation when using context managers
as function decorators: there's no way to access the return value of
__enter__(). If that value is needed, then it is still necessary to use
an explicit with statement.
参见
Python with 语句的规范描述、背景和示例。
Most context managers are written in a way that means they can only be
used effectively in a with statement once. These single use
context managers must be created afresh each time they're used -
attempting to use them a second time will trigger an exception or
otherwise not work correctly.
This common limitation means that it is generally advisable to create
context managers directly in the header of the with statement
where they are used (as shown in all of the usage examples above).
Files are an example of effectively single use context managers, since
the first with statement will close the file, preventing any
further IO operations using that file object.
Context managers created using contextmanager() are also single use
context managers, and will complain about the underlying generator failing
to yield if an attempt is made to use them a second time:
More sophisticated context managers may be "reentrant". These context
managers can not only be used in multiple with statements,
but may also be used inside a with statement that is already
using the same context manager.
threading.RLock is an example of a reentrant context manager, as are
suppress() and redirect_stdout(). Here's a very simple example of
reentrant use:
Real world examples of reentrancy are more likely to involve multiple
functions calling each other and hence be far more complicated than this
example.
Note also that being reentrant is not the same thing as being thread safe.
redirect_stdout(), for example, is definitely not thread safe, as it
makes a global modification to the system state by binding sys.stdout
to a different stream.
Distinct from both single use and reentrant context managers are "reusable"
context managers (or, to be completely explicit, "reusable, but not
reentrant" context managers, since reentrant context managers are also
reusable). These context managers support being used multiple times, but
will fail (or otherwise not work correctly) if the specific context manager
instance has already been used in a containing with statement.
threading.Lock is an example of a reusable, but not reentrant,
context manager (for a reentrant lock, it is necessary to use
threading.RLock instead).
Another example of a reusable, but not reentrant, context manager is
ExitStack, as it invokes all currently registered callbacks
when leaving any with statement, regardless of where those callbacks
were added:
As the output from the example shows, reusing a single stack object across
multiple with statements works correctly, but attempting to nest them
will cause the stack to be cleared at the end of the innermost with
statement, which is unlikely to be desirable behaviour.
Using separate ExitStack instances instead of reusing a single
instance avoids that problem:
dataclasses --- 数据类
abc --- 抽象基类
</body></doc>