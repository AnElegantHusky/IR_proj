<?xml version='1.0' encoding='utf-8'?>
<doc><id>318</id><url>https://docs.python.org/zh-cn/3/howto/unicode.html</url><title>Unicode 指南</title><body>1.12
本指南讨论了 Python 对于表达文本数据的 Unicode 规范的支持，并且解释了人们试图使用 Unicode 时经常遇到的问题。
如今的程序需要具有处理许多不同类型字符的能力。应用程序常常需要国际化以便以用户可选择的不同语言显示信息和输出。同一个程序可能需要以英语、法语、日语、希伯来语或俄语输出错误信息。网页内容可能由任何语言写成，并且可能包含不同的表情符号。Python 的字符串类型使用 Unicode 标准来表示字符，这使 Python 程序能够正常处理所有这些可能的字符。
Unicode 规范 (https://www.unicode.org/) 旨在列出人类语言中用到的每个字符，并赋予每个字符唯一的编码。该规范持续进行修订和更新以添加新的语言和符号。
一个**字符**是文本的最小可能部件。‘A’、‘B’、‘C’ 等都是不同的字符。‘È’ 和 ‘Í’ 也一样。字符会随着语言或者上下文的变化而变化。比如，‘Ⅰ’ 是一个表示 “罗马数字 1” 的字符，它与大写字母 ‘I’ 不同。它们常常看起来相同，但这是两个有着不同含义的不同字符。
Unicode 标准描述了**码位**如何表示字符。一个码位的值是在 0 到 0x10FFFF （大约 110 万个值，目前有其中 11 万个被指派）。在这一标准中并且在这一文档中，一个码位写作 U+265E 来表示拥有值 0x265e 的字符（十进制下为 9,822）。
Unicode 标准包含了许多表格来列出字符和对应的码位。
严格地说，这些定义暗示了这样的说法是没有意义的：“这是字符 U+265E”。U+265E 是一个码位，其代表了某特定的字符 —— 在这一情形下，它代表了字符 “国际象棋黑方骑士（黑马）” ‘♞’。在非正式上下文中，码位和字符的差异有时会被忽略。
一个字符在屏幕上或在纸上被表示为一组图形元素，被称为**字形**。比如，大写字母 A 的字形，是斜向的两笔和水平的一笔，而具体的细节取决于所使用的字体。大部分 Python 代码不必担心字形，找到应被显示的正确字形一般来说是用户图形界面工具箱或者终端的字体渲染器的工作。
上一段可以归结为：一个 Unicode 字符串是一系列码位（从 0 到 0x10FFFF 或者说十进制的 1,114,111 的数字）组成的序列。这一序列在内存中需要被表示为一组**码元**，然后**码元** 会对应到包含八个二进制位的字节。将 Unicode 字符串翻译成字节序列的规则被称为**字符编码**，或者**编码**。
你可能会想到的第一种编码是使用一个 32 位的整数来代表一个代码位，然后使用 CPU 对 32 位整数的表达方式。在这一表达方式中，字符串 “Python” 可能看起来像是这样：
这个表达方式非常直接，但同时也存在 一些问题。
不够方便；不同的处理器对字节的排序不同。
非常浪费空间。多数编码都小于127，或者255，所以很多空间都是 0x00。上面的字符串takes 24 bytes compared to the 6 bytes needed for an ASCII representation. Increased RAM usage doesn't matter too much (desktop computers have gigabytes of RAM, and strings aren't usually that large), but expanding our usage of disk and network bandwidth by a factor of 4 is intolerable.
It's not compatible with existing C functions such as strlen(), so a new
family of wide string functions would need to be used.
Therefore this encoding isn't used very much, and people instead choose other
encodings that are more efficient and convenient, such as UTF-8.
UTF-8 is one of the most commonly used encodings, and Python often
defaults to using it.  UTF stands for "Unicode Transformation Format",
and the '8' means that 8-bit values are used in the encoding.  (There
are also UTF-16 and UTF-32 encodings, but they are less frequently
used than UTF-8.)  UTF-8 uses the following rules:
If the code point is &lt; 128, it's represented by the corresponding byte value.
If the code point is &gt;= 128, it's turned into a sequence of two, three, or
four bytes, where each byte of the sequence is between 128 and 255.
UTF-8 has several convenient properties:
It can handle any Unicode code point.
A Unicode string is turned into a sequence of bytes that contains embedded
zero bytes only where they represent the null character (U+0000). This means
that UTF-8 strings can be processed by C functions such as strcpy() and sent
through protocols that can't handle zero bytes for anything other than
end-of-string markers.
A string of ASCII text is also valid UTF-8 text.
UTF-8 is fairly compact; the majority of commonly used characters can be
represented with one or two bytes.
If bytes are corrupted or lost, it's possible to determine the start of the
next UTF-8-encoded code point and resynchronize.  It's also unlikely that
random 8-bit data will look like valid UTF-8.
UTF-8 is a byte oriented encoding. The encoding specifies that each
character is represented by a specific sequence of one or more bytes. This
avoids the byte-ordering issues that can occur with integer and word oriented
encodings, like UTF-16 and UTF-32, where the sequence of bytes varies depending
on the hardware on which the string was encoded.
The Unicode Consortium site has character charts, a
glossary, and PDF versions of the Unicode specification.  Be prepared for some
difficult reading.  A chronology of the
origin and development of Unicode is also available on the site.
On the Computerphile Youtube channel, Tom Scott briefly
discusses the history of Unicode and UTF-8
(9 minutes 36 seconds).
To help understand the standard, Jukka Korpela has written an introductory
guide to reading the
Unicode character tables.
Another good introductory article
was written by Joel Spolsky.
If this introduction didn't make things clear to you, you should try
reading this alternate article before continuing.
Wikipedia entries are often helpful; see the entries for "character encoding" and UTF-8, for example.
Now that you've learned the rudiments of Unicode, we can look at Python's
Unicode features.
Since Python 3.0, the language's str type contains Unicode
characters, meaning any string created using "unicode rocks!", 'unicode
rocks!', or the triple-quoted string syntax is stored as Unicode.
The default encoding for Python source code is UTF-8, so you can simply
include a Unicode character in a string literal:
Side note: Python 3 also supports using Unicode characters in identifiers:
If you can't enter a particular character in your editor or want to
keep the source code ASCII-only for some reason, you can also use
escape sequences in string literals. (Depending on your system,
you may see the actual capital-delta glyph instead of a u escape.)
In addition, one can create a string using the decode() method of
bytes.  This method takes an encoding argument, such as UTF-8,
and optionally an errors argument.
The errors argument specifies the response when the input string can't be
converted according to the encoding's rules.  Legal values for this argument are
'strict' (raise a UnicodeDecodeError exception), 'replace' (use
U+FFFD, REPLACEMENT CHARACTER), 'ignore' (just leave the
character out of the Unicode result), or 'backslashreplace' (inserts a
\xNN escape sequence).
The following examples show the differences:
Encodings are specified as strings containing the encoding's name.  Python
comes with roughly 100 different encodings; see the Python Library Reference at
标准编码 for a list.  Some encodings have multiple names; for
example, 'latin-1', 'iso_8859_1' and '8859' are all synonyms for
the same encoding.
One-character Unicode strings can also be created with the chr()
built-in function, which takes integers and returns a Unicode string of length 1
that contains the corresponding code point.  The reverse operation is the
built-in ord() function that takes a one-character Unicode string and
returns the code point value:
The opposite method of bytes.decode() is str.encode(),
which returns a bytes representation of the Unicode string, encoded in the
requested encoding.
The errors parameter is the same as the parameter of the
decode() method but supports a few more possible handlers. As well as
'strict', 'ignore', and 'replace' (which in this case
inserts a question mark instead of the unencodable character), there is
also 'xmlcharrefreplace' (inserts an XML character reference),
backslashreplace (inserts a \uNNNN escape sequence) and
namereplace (inserts a \N{...} escape sequence).
The following example shows the different results:
The low-level routines for registering and accessing the available
encodings are found in the codecs module.  Implementing new
encodings also requires understanding the codecs module.
However, the encoding and decoding functions returned by this module
are usually more low-level than is comfortable, and writing new encodings
is a specialized task, so the module won't be covered in this HOWTO.
In Python source code, specific Unicode code points can be written using the
\u escape sequence, which is followed by four hex digits giving the code
point.  The \U escape sequence is similar, but expects eight hex digits,
not four:
Using escape sequences for code points greater than 127 is fine in small doses,
but becomes an annoyance if you're using many accented characters, as you would
in a program with messages in French or some other accent-using language.  You
can also assemble strings using the chr() built-in function, but this is
even more tedious.
Ideally, you'd want to be able to write literals in your language's natural
encoding.  You could then edit Python source code with your favorite editor
which would display the accented characters naturally, and have the right
characters used at runtime.
Python supports writing source code in UTF-8 by default, but you can use almost
any encoding if you declare the encoding being used.  This is done by including
a special comment as either the first or second line of the source file:
The syntax is inspired by Emacs's notation for specifying variables local to a
file.  Emacs supports many different variables, but Python only supports
'coding'.  The -*- symbols indicate to Emacs that the comment is special;
they have no significance to Python but are a convention.  Python looks for
coding: name or coding=name in the comment.
If you don't include such a comment, the default encoding used will be UTF-8 as
already mentioned.  See also PEP 263 for more information.
The Unicode specification includes a database of information about
code points.  For each defined code point, the information includes
the character's name, its category, the numeric value if applicable
(for characters representing numeric concepts such as the Roman
numerals, fractions such as one-third and four-fifths, etc.).  There
are also display-related properties, such as how to use the code point
in bidirectional text.
The following program displays some information about several characters, and
prints the numeric value of one particular character:
When run, this prints:
The category codes are abbreviations describing the nature of the character.
These are grouped into categories such as "Letter", "Number", "Punctuation", or
"Symbol", which in turn are broken up into subcategories.  To take the codes
from the above output, 'Ll' means 'Letter, lowercase', 'No' means
"Number, other", 'Mn' is "Mark, nonspacing", and 'So' is "Symbol,
other".  See
the General Category Values section of the Unicode Character Database documentation for a
list of category codes.
Unicode adds some complication to comparing strings, because the same
set of characters can be represented by different sequences of code
points.  For example, a letter like 'ê' can be represented as a single
code point U+00EA, or as U+0065 U+0302, which is the code point for
'e' followed by a code point for 'COMBINING CIRCUMFLEX ACCENT'.  These
will produce the same output when printed, but one is a string of
length 1 and the other is of length 2.
One tool for a case-insensitive comparison is the
casefold() string method that converts a string to a
case-insensitive form following an algorithm described by the Unicode
Standard.  This algorithm has special handling for characters such as
the German letter 'ß' (code point U+00DF), which becomes the pair of
lowercase letters 'ss'.
A second tool is the unicodedata module's
normalize() function that converts strings to one
of several normal forms, where letters followed by a combining
character are replaced with single characters.  normalize() can
be used to perform string comparisons that won't falsely report
inequality if two strings use combining characters differently:
When run, this outputs:
The first argument to the normalize() function is a
string giving the desired normalization form, which can be one of
'NFC', 'NFKC', 'NFD', and 'NFKD'.
The Unicode Standard also specifies how to do caseless comparisons:
This will print True.  (Why is NFD() invoked twice?  Because
there are a few characters that make casefold() return a
non-normalized string, so the result needs to be normalized again. See
section 3.13 of the Unicode Standard for a discussion and an example.)
The regular expressions supported by the re module can be provided
either as bytes or strings.  Some of the special character sequences such as
\d and \w have different meanings depending on whether
the pattern is supplied as bytes or a string.  For example,
\d will match the characters [0-9] in bytes but
in strings will match any character that's in the 'Nd' category.
The string in this example has the number 57 written in both Thai and
Arabic numerals:
When executed, \d+ will match the Thai numerals and print them
out.  If you supply the re.ASCII flag to
compile(), \d+ will match the substring "57" instead.
Similarly, \w matches a wide variety of Unicode characters but
only [a-zA-Z0-9_] in bytes or if re.ASCII is supplied,
and \s will match either Unicode whitespace characters or
[ \t\n\r\f\v].
Some good alternative discussions of Python's Unicode support are:
Processing Text Files in Python 3, by Nick Coghlan.
Pragmatic Unicode, a PyCon 2012 presentation by Ned Batchelder.
The str type is described in the Python library reference at
文本序列类型 --- str.
The documentation for the unicodedata module.
The documentation for the codecs module.
Marc-André Lemburg gave a presentation titled "Python and Unicode" (PDF slides) at
EuroPython 2002.  The slides are an excellent overview of the design of Python
2's Unicode features (where the Unicode string type is called unicode and
literals start with u).
Once you've written some code that works with Unicode data, the next problem is
input/output.  How do you get Unicode strings into your program, and how do you
convert Unicode into a form suitable for storage or transmission?
It's possible that you may not need to do anything depending on your input
sources and output destinations; you should check whether the libraries used in
your application support Unicode natively.  XML parsers often return Unicode
data, for example.  Many relational databases also support Unicode-valued
columns and can return Unicode values from an SQL query.
Unicode data is usually converted to a particular encoding before it gets
written to disk or sent over a socket.  It's possible to do all the work
yourself: open a file, read an 8-bit bytes object from it, and convert the bytes
with bytes.decode(encoding).  However, the manual approach is not recommended.
One problem is the multi-byte nature of encodings; one Unicode character can be
represented by several bytes.  If you want to read the file in arbitrary-sized
chunks (say, 1024 or 4096 bytes), you need to write error-handling code to catch the case
where only part of the bytes encoding a single Unicode character are read at the
end of a chunk.  One solution would be to read the entire file into memory and
then perform the decoding, but that prevents you from working with files that
are extremely large; if you need to read a 2 GiB file, you need 2 GiB of RAM.
(More, really, since for at least a moment you'd need to have both the encoded
string and its Unicode version in memory.)
The solution would be to use the low-level decoding interface to catch the case
of partial coding sequences.  The work of implementing this has already been
done for you: the built-in open() function can return a file-like object
that assumes the file's contents are in a specified encoding and accepts Unicode
parameters for methods such as read() and
write().  This works through open()'s encoding and
errors parameters which are interpreted just like those in str.encode()
and bytes.decode().
Reading Unicode from a file is therefore simple:
It's also possible to open files in update mode, allowing both reading and
writing:
The Unicode character U+FEFF is used as a byte-order mark (BOM), and is often
written as the first character of a file in order to assist with autodetection
of the file's byte ordering.  Some encodings, such as UTF-16, expect a BOM to be
present at the start of a file; when such an encoding is used, the BOM will be
automatically written as the first character and will be silently dropped when
the file is read.  There are variants of these encodings, such as 'utf-16-le'
and 'utf-16-be' for little-endian and big-endian encodings, that specify one
particular byte ordering and don't skip the BOM.
In some areas, it is also convention to use a "BOM" at the start of UTF-8
encoded files; the name is misleading since UTF-8 is not byte-order dependent.
The mark simply announces that the file is encoded in UTF-8.  For reading such
files, use the 'utf-8-sig' codec to automatically skip the mark if present.
Most of the operating systems in common use today support filenames
that contain arbitrary Unicode characters.  Usually this is
implemented by converting the Unicode string into some encoding that
varies depending on the system.  Today Python is converging on using
UTF-8: Python on MacOS has used UTF-8 for several versions, and Python
3.6 switched to using UTF-8 on Windows as well.  On Unix systems,
there will only be a filesystem encoding if you've set the LANG or
LC_CTYPE environment variables; if you haven't, the default
encoding is again UTF-8.
The sys.getfilesystemencoding() function returns the encoding to use on
your current system, in case you want to do the encoding manually, but there's
not much reason to bother.  When opening a file for reading or writing, you can
usually just provide the Unicode string as the filename, and it will be
automatically converted to the right encoding for you:
Functions in the os module such as os.stat() will also accept Unicode
filenames.
The os.listdir() function returns filenames, which raises an issue: should it return
the Unicode version of filenames, or should it return bytes containing
the encoded versions?  os.listdir() can do both, depending on whether you
provided the directory path as bytes or a Unicode string.  If you pass a
Unicode string as the path, filenames will be decoded using the filesystem's
encoding and a list of Unicode strings will be returned, while passing a byte
path will return the filenames as bytes.  For example,
assuming the default filesystem encoding is UTF-8, running the following
program:
will produce the following output:
The first list contains UTF-8-encoded filenames, and the second list contains
the Unicode versions.
Note that on most occasions, you should can just stick with using
Unicode with these APIs.  The bytes APIs should only be used on
systems where undecodable file names can be present; that's
pretty much only Unix systems now.
This section provides some suggestions on writing software that deals with
Unicode.
The most important tip is:
Software should only work with Unicode strings internally, decoding the input
data as soon as possible and encoding the output only at the end.
If you attempt to write processing functions that accept both Unicode and byte
strings, you will find your program vulnerable to bugs wherever you combine the
two different kinds of strings.  There is no automatic encoding or decoding: if
you do e.g. str + bytes, a TypeError will be raised.
When using data coming from a web browser or some other untrusted source, a
common technique is to check for illegal characters in a string before using the
string in a generated command line or storing it in a database.  If you're doing
this, be careful to check the decoded string, not the encoded bytes data;
some encodings may have interesting properties, such as not being bijective
or not being fully ASCII-compatible.  This is especially true if the input
data also specifies the encoding, since the attacker can then choose a
clever way to hide malicious text in the encoded bytestream.
The StreamRecoder class can transparently convert between
encodings, taking a stream that returns data in encoding #1
and behaving like a stream returning data in encoding #2.
For example, if you have an input file f that's in Latin-1, you
can wrap it with a StreamRecoder to return bytes encoded in
UTF-8:
What can you do if you need to make a change to a file, but don't know
the file's encoding?  If you know the encoding is ASCII-compatible and
only want to examine or modify the ASCII parts, you can open the file
with the surrogateescape error handler:
The surrogateescape error handler will decode any non-ASCII bytes
as code points in a special range running from U+DC80 to
U+DCFF.  These code points will then turn back into the
same bytes when the surrogateescape error handler is used to
encode the data and write it back out.
One section of Mastering Python 3 Input/Output,
a PyCon 2010 talk by David Beazley, discusses text processing and binary data handling.
The PDF slides for Marc-André Lemburg's presentation "Writing Unicode-aware
Applications in Python"
discuss questions of character encodings as well as how to internationalize
and localize an application.  These slides cover Python 2.x only.
The Guts of Unicode in Python
is a PyCon 2013 talk by Benjamin Peterson that discusses the internal Unicode
representation in Python 3.3.
The initial draft of this document was written by Andrew Kuchling.
It has since been revised further by Alexander Belopolsky, Georg Brandl,
Andrew Kuchling, and Ezio Melotti.
Thanks to the following people who have noted errors or offered
suggestions on this article: Éric Araujo, Nicholas Bastin, Nick
Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-André
Lemburg, Martin von Löwis, Terry J. Reedy, Serhiy Storchaka,
Eryk Sun, Chad Whitacre, Graham Wideman.
排序指南
HOWTO 使用 urllib 包获取网络资源
</body></doc>