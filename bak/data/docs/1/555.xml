<?xml version='1.0' encoding='utf-8'?>
<doc><id>555</id><url>https://docs.python.org/zh-cn/3/library/ssl.html</url><title> --- 套接字对象的TLS/SSL封装</title><body>源代码: Lib/ssl.py
This module provides access to Transport Layer Security (often known as "Secure
Sockets Layer") encryption and peer authentication facilities for network
sockets, both client-side and server-side.  This module uses the OpenSSL
library. It is available on all modern Unix systems, Windows, Mac OS X, and
probably additional platforms, as long as OpenSSL is installed on that platform.
注解
Some behavior may be platform dependent, since calls are made to the
operating system socket APIs.  The installed version of OpenSSL may also
cause variations in behavior. For example, TLSv1.1 and TLSv1.2 come with
openssl version 1.0.1.
警告
Don't use this module without reading the Security considerations.  Doing so
may lead to a false sense of security, as the default settings of the
ssl module are not necessarily appropriate for your application.
This section documents the objects and functions in the ssl module; for more
general information about TLS, SSL, and certificates, the reader is referred to
the documents in the "See Also" section at the bottom.
This module provides a class, ssl.SSLSocket, which is derived from the
socket.socket type, and provides a socket-like wrapper that also
encrypts and decrypts the data going over the socket with SSL.  It supports
additional methods such as getpeercert(), which retrieves the
certificate of the other side of the connection, and cipher(), which
retrieves the cipher being used for the secure connection.
For more sophisticated applications, the ssl.SSLContext class
helps manage settings and certificates, which can then be inherited
by SSL sockets created through the SSLContext.wrap_socket() method.
在 3.5.3 版更改: Updated to support linking with OpenSSL 1.1.0
在 3.6 版更改: OpenSSL 0.9.8, 1.0.0 and 1.0.1 are deprecated and no longer supported.
In the future the ssl module will require at least OpenSSL 1.0.2 or
1.1.0.
Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() of an SSLContext instance to wrap
sockets as SSLSocket objects. The helper functions
create_default_context() returns a new context with secure default
settings. The old wrap_socket() function is deprecated since it is
both inefficient and has no support for server name indication (SNI) and
hostname matching.
Client socket example with default context and IPv4/IPv6 dual stack:
Client socket example with custom context and IPv4:
Server socket example listening on localhost IPv4:
A convenience function helps create SSLContext objects for common
purposes.
Return a new SSLContext object with default settings for
the given purpose.  The settings are chosen by the ssl module,
and usually represent a higher security level than when calling the
SSLContext constructor directly.
cafile, capath, cadata represent optional CA certificates to
trust for certificate verification, as in
SSLContext.load_verify_locations().  If all three are
None, this function can choose to trust the system's default
CA certificates instead.
The settings are: PROTOCOL_TLS, OP_NO_SSLv2, and
OP_NO_SSLv3 with high encryption cipher suites without RC4 and
without unauthenticated cipher suites. Passing SERVER_AUTH
as purpose sets verify_mode to CERT_REQUIRED
and either loads CA certificates (when at least one of cafile, capath or
cadata is given) or uses SSLContext.load_default_certs() to load
default CA certificates.
When keylog_filename is supported and the environment
variable SSLKEYLOGFILE is set, create_default_context()
enables key logging.
注解
The protocol, options, cipher and other settings may change to more
restrictive values anytime without prior deprecation.  The values
represent a fair balance between compatibility and security.
If your application needs specific settings, you should create a
SSLContext and apply the settings yourself.
注解
If you find that when certain older clients or servers attempt to connect
with a SSLContext created by this function that they get an error
stating "Protocol or cipher suite mismatch", it may be that they only
support SSL3.0 which this function excludes using the
OP_NO_SSLv3. SSL3.0 is widely considered to be completely broken. If you still wish to continue to
use this function but still allow SSL 3.0 connections you can re-enable
them using:
3.4 新版功能.
在 3.4.4 版更改: RC4 was dropped from the default cipher string.
在 3.6 版更改: ChaCha20/Poly1305 was added to the default cipher string.
3DES was dropped from the default cipher string.
在 3.8 版更改: Support for key logging to SSLKEYLOGFILE was added.
Raised to signal an error from the underlying SSL implementation
(currently provided by the OpenSSL library).  This signifies some
problem in the higher-level encryption and authentication layer that's
superimposed on the underlying network connection.  This error
is a subtype of OSError.  The error code and message of
SSLError instances are provided by the OpenSSL library.
在 3.3 版更改: SSLError used to be a subtype of socket.error.
A string mnemonic designating the OpenSSL submodule in which the error
occurred, such as SSL, PEM or X509.  The range of possible
values depends on the OpenSSL version.
3.3 新版功能.
A string mnemonic designating the reason this error occurred, for
example CERTIFICATE_VERIFY_FAILED.  The range of possible
values depends on the OpenSSL version.
3.3 新版功能.
A subclass of SSLError raised when trying to read or write and
the SSL connection has been closed cleanly.  Note that this doesn't
mean that the underlying transport (read TCP) has been closed.
3.3 新版功能.
A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs
to be received on the underlying TCP transport before the request can be
fulfilled.
3.3 新版功能.
A subclass of SSLError raised by a non-blocking SSL socket when trying to read or write data, but more data needs
to be sent on the underlying TCP transport before the request can be
fulfilled.
3.3 新版功能.
A subclass of SSLError raised when a system error was encountered
while trying to fulfill an operation on a SSL socket.  Unfortunately,
there is no easy way to inspect the original errno number.
3.3 新版功能.
A subclass of SSLError raised when the SSL connection has been
terminated abruptly.  Generally, you shouldn't try to reuse the underlying
transport when this error is encountered.
3.3 新版功能.
A subclass of SSLError raised when certificate validation has
failed.
3.7 新版功能.
A numeric error number that denotes the verification error.
A human readable string of the verification error.
An alias for SSLCertVerificationError.
在 3.7 版更改: The exception is now an alias for SSLCertVerificationError.
Return num cryptographically strong pseudo-random bytes. Raises an
SSLError if the PRNG has not been seeded with enough data or if the
operation is not supported by the current RAND method. RAND_status()
can be used to check the status of the PRNG and RAND_add() can be used
to seed the PRNG.
For almost all applications os.urandom() is preferable.
Read the Wikipedia article, Cryptographically secure pseudorandom number
generator (CSPRNG),
to get the requirements of a cryptographically generator.
3.3 新版功能.
Return (bytes, is_cryptographic): bytes are num pseudo-random bytes,
is_cryptographic is True if the bytes generated are cryptographically
strong. Raises an SSLError if the operation is not supported by the
current RAND method.
Generated pseudo-random byte sequences will be unique if they are of
sufficient length, but are not necessarily unpredictable. They can be used
for non-cryptographic purposes and for certain purposes in cryptographic
protocols, but usually not for key generation etc.
For almost all applications os.urandom() is preferable.
3.3 新版功能.
3.6 版后已移除: OpenSSL has deprecated ssl.RAND_pseudo_bytes(), use
ssl.RAND_bytes() instead.
Return True if the SSL pseudo-random number generator has been seeded
with 'enough' randomness, and False otherwise.  You can use
ssl.RAND_egd() and ssl.RAND_add() to increase the randomness of
the pseudo-random number generator.
If you are running an entropy-gathering daemon (EGD) somewhere, and path
is the pathname of a socket connection open to it, this will read 256 bytes
of randomness from the socket, and add it to the SSL pseudo-random number
generator to increase the security of generated secret keys.  This is
typically only necessary on systems without better sources of randomness.
See http://egd.sourceforge.net/ or http://prngd.sourceforge.net/ for sources
of entropy-gathering daemons.
Availability: not available with LibreSSL and OpenSSL &gt; 1.1.0.
Mix the given bytes into the SSL pseudo-random number generator.  The
parameter entropy (a float) is a lower bound on the entropy contained in
string (so you can always use 0.0).  See RFC 1750 for more
information on sources of entropy.
在 3.5 版更改: 现在支持可写的 字节类对象。
Verify that cert (in decoded format as returned by
SSLSocket.getpeercert()) matches the given hostname.  The rules
applied are those for checking the identity of HTTPS servers as outlined
in RFC 2818, RFC 5280 and RFC 6125.  In addition to HTTPS, this
function should be suitable for checking the identity of servers in
various SSL-based protocols such as FTPS, IMAPS, POPS and others.
CertificateError is raised on failure. On success, the function
returns nothing:
3.2 新版功能.
在 3.3.3 版更改: The function now follows RFC 6125, section 6.4.3 and does neither
match multiple wildcards (e.g. *.*.com or *a*.example.org) nor
a wildcard inside an internationalized domain names (IDN) fragment.
IDN A-labels such as www*.xn--pthon-kva.org are still supported,
but x*.python.org no longer matches xn--tda.python.org.
在 3.5 版更改: Matching of IP addresses, when present in the subjectAltName field
of the certificate, is now supported.
在 3.7 版更改: The function is no longer used to TLS connections. Hostname matching
is now performed by OpenSSL.
Allow wildcard when it is the leftmost and the only character
in that segment. Partial wildcards like www*.example.com are no
longer supported.
3.7 版后已移除.
Return the time in seconds since the Epoch, given the cert_time
string representing the "notBefore" or "notAfter" date from a
certificate in "%b %d %H:%M:%S %Y %Z" strptime format (C
locale).
Here's an example:
"notBefore" or "notAfter" dates must use GMT (RFC 5280).
在 3.5 版更改: Interpret the input time as a time in UTC as specified by 'GMT'
timezone in the input string. Local timezone was used
previously. Return an integer (no fractions of a second in the
input format)
Given the address addr of an SSL-protected server, as a (hostname,
port-number) pair, fetches the server's certificate, and returns it as a
PEM-encoded string.  If ssl_version is specified, uses that version of
the SSL protocol to attempt to connect to the server.  If ca_certs is
specified, it should be a file containing a list of root certificates, the
same format as used for the same parameter in
SSLContext.wrap_socket().  The call will attempt to validate the
server certificate against that set of root certificates, and will fail
if the validation attempt fails.
在 3.3 版更改: This function is now IPv6-compatible.
在 3.5 版更改: The default ssl_version is changed from PROTOCOL_SSLv3 to
PROTOCOL_TLS for maximum compatibility with modern servers.
Given a certificate as a DER-encoded blob of bytes, returns a PEM-encoded
string version of the same certificate.
Given a certificate as an ASCII PEM string, returns a DER-encoded sequence of
bytes for that same certificate.
Returns a named tuple with paths to OpenSSL's default cafile and capath.
The paths are the same as used by
SSLContext.set_default_verify_paths(). The return value is a
named tuple DefaultVerifyPaths:
cafile - resolved path to cafile or None if the file doesn't exist,
capath - resolved path to capath or None if the directory doesn't exist,
openssl_cafile_env - OpenSSL's environment key that points to a cafile,
openssl_cafile - hard coded path to a cafile,
openssl_capath_env - OpenSSL's environment key that points to a capath,
openssl_capath - hard coded path to a capath directory
Availability: LibreSSL ignores the environment vars
openssl_cafile_env and openssl_capath_env.
3.4 新版功能.
Retrieve certificates from Windows' system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data. Trust specifies the purpose of the certificate as a set
of OIDS or exactly True if the certificate is trustworthy for all
purposes.
示例:
可用性: Windows。
3.4 新版功能.
Retrieve CRLs from Windows' system cert store. store_name may be
one of CA, ROOT or MY. Windows may provide additional cert
stores, too.
The function returns a list of (cert_bytes, encoding_type, trust) tuples.
The encoding_type specifies the encoding of cert_bytes. It is either
x509_asn for X.509 ASN.1 data or pkcs_7_asn for
PKCS#7 ASN.1 data.
可用性: Windows。
3.4 新版功能.
Takes an instance sock of socket.socket, and returns an instance
of ssl.SSLSocket, a subtype of socket.socket, which wraps
the underlying socket in an SSL context.  sock must be a
SOCK_STREAM socket; other socket types are unsupported.
Internally, function creates a SSLContext with protocol
ssl_version and SSLContext.options set to cert_reqs. If
parameters keyfile, certfile, ca_certs or ciphers are set, then
the values are passed to SSLContext.load_cert_chain(),
SSLContext.load_verify_locations(), and
SSLContext.set_ciphers().
The arguments server_side, do_handshake_on_connect, and
suppress_ragged_eofs have the same meaning as
SSLContext.wrap_socket().
3.7 版后已移除: Since Python 3.2 and 2.7.9, it is recommended to use the
SSLContext.wrap_socket() instead of wrap_socket(). The
top-level function is limited and creates an insecure client socket
without server name indication or hostname matching.
All constants are now enum.IntEnum or enum.IntFlag collections.
3.6 新版功能.
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  Except for PROTOCOL_TLS_CLIENT,
it is the default mode.  With client-side sockets, just about any
cert is accepted.  Validation errors, such as untrusted or expired cert,
are ignored and do not abort the TLS/SSL handshake.
In server mode, no certificate is requested from the client, so the client
does not send any for client cert authentication.
See the discussion of Security considerations below.
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  In client mode, CERT_OPTIONAL
has the same meaning as CERT_REQUIRED. It is recommended to
use CERT_REQUIRED for client-side sockets instead.
In server mode, a client certificate request is sent to the client.  The
client may either ignore the request or send a certificate in order
perform TLS client cert authentication.  If the client chooses to send
a certificate, it is verified.  Any verification error immediately aborts
the TLS handshake.
Use of this setting requires a valid set of CA certificates to
be passed, either to SSLContext.load_verify_locations() or as a
value of the ca_certs parameter to wrap_socket().
Possible value for SSLContext.verify_mode, or the cert_reqs
parameter to wrap_socket().  In this mode, certificates are
required from the other side of the socket connection; an SSLError
will be raised if no certificate is provided, or if its validation fails.
This mode is not sufficient to verify a certificate in client mode as
it does not match hostnames.  check_hostname must be
enabled as well to verify the authenticity of a cert.
PROTOCOL_TLS_CLIENT uses CERT_REQUIRED and
enables check_hostname by default.
With server socket, this mode provides mandatory TLS client cert
authentication.  A client certificate request is sent to the client and
the client must provide a valid and trusted certificate.
Use of this setting requires a valid set of CA certificates to
be passed, either to SSLContext.load_verify_locations() or as a
value of the ca_certs parameter to wrap_socket().
enum.IntEnum collection of CERT_* constants.
3.6 新版功能.
Possible value for SSLContext.verify_flags. In this mode, certificate
revocation lists (CRLs) are not checked. By default OpenSSL does neither
require nor verify CRLs.
3.4 新版功能.
Possible value for SSLContext.verify_flags. In this mode, only the
peer cert is checked but none of the intermediate CA certificates. The mode
requires a valid CRL that is signed by the peer cert's issuer (its direct
ancestor CA). If no proper CRL has has been loaded with
SSLContext.load_verify_locations, validation will fail.
3.4 新版功能.
Possible value for SSLContext.verify_flags. In this mode, CRLs of
all certificates in the peer cert chain are checked.
3.4 新版功能.
Possible value for SSLContext.verify_flags to disable workarounds
for broken X.509 certificates.
3.4 新版功能.
Possible value for SSLContext.verify_flags. It instructs OpenSSL to
prefer trusted certificates when building the trust chain to validate a
certificate. This flag is enabled by default.
3.4.4 新版功能.
enum.IntFlag collection of VERIFY_* constants.
3.6 新版功能.
Selects the highest protocol version that both the client and server support.
Despite the name, this option can select both "SSL" and "TLS" protocols.
3.6 新版功能.
Auto-negotiate the highest protocol version like PROTOCOL_TLS,
but only support client-side SSLSocket connections. The protocol
enables CERT_REQUIRED and check_hostname by
default.
3.6 新版功能.
Auto-negotiate the highest protocol version like PROTOCOL_TLS,
but only support server-side SSLSocket connections.
3.6 新版功能.
Alias for PROTOCOL_TLS.
3.6 版后已移除: Use PROTOCOL_TLS instead.
Selects SSL version 2 as the channel encryption protocol.
This protocol is not available if OpenSSL is compiled with the
OPENSSL_NO_SSL2 flag.
警告
SSL version 2 is insecure.  Its use is highly discouraged.
3.6 版后已移除: OpenSSL has removed support for SSLv2.
Selects SSL version 3 as the channel encryption protocol.
This protocol is not be available if OpenSSL is compiled with the
OPENSSL_NO_SSLv3 flag.
警告
SSL version 3 is insecure.  Its use is highly discouraged.
3.6 版后已移除: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.
Selects TLS version 1.0 as the channel encryption protocol.
3.6 版后已移除: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.
Selects TLS version 1.1 as the channel encryption protocol.
Available only with openssl version 1.0.1+.
3.4 新版功能.
3.6 版后已移除: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.
Selects TLS version 1.2 as the channel encryption protocol. This is the
most modern version, and probably the best choice for maximum protection,
if both sides can speak it.  Available only with openssl version 1.0.1+.
3.4 新版功能.
3.6 版后已移除: OpenSSL has deprecated all version specific protocols. Use the default
protocol PROTOCOL_TLS with flags like OP_NO_SSLv3 instead.
Enables workarounds for various bugs present in other SSL implementations.
This option is set by default.  It does not necessarily set the same
flags as OpenSSL's SSL_OP_ALL constant.
3.2 新版功能.
Prevents an SSLv2 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing SSLv2 as the protocol version.
3.2 新版功能.
3.6 版后已移除: SSLv2 is deprecated
Prevents an SSLv3 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing SSLv3 as the protocol version.
3.2 新版功能.
3.6 版后已移除: SSLv3 is deprecated
Prevents a TLSv1 connection.  This option is only applicable in
conjunction with PROTOCOL_TLS.  It prevents the peers from
choosing TLSv1 as the protocol version.
3.2 新版功能.
3.7 版后已移除: The option is deprecated since OpenSSL 1.1.0, use the new
SSLContext.minimum_version and
SSLContext.maximum_version instead.
Prevents a TLSv1.1 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.1 as
the protocol version. Available only with openssl version 1.0.1+.
3.4 新版功能.
3.7 版后已移除: The option is deprecated since OpenSSL 1.1.0.
Prevents a TLSv1.2 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.2 as
the protocol version. Available only with openssl version 1.0.1+.
3.4 新版功能.
3.7 版后已移除: The option is deprecated since OpenSSL 1.1.0.
Prevents a TLSv1.3 connection. This option is only applicable in conjunction
with PROTOCOL_TLS. It prevents the peers from choosing TLSv1.3 as
the protocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later.
When Python has been compiled against an older version of OpenSSL, the
flag defaults to 0.
3.7 新版功能.
3.7 版后已移除: The option is deprecated since OpenSSL 1.1.0. It was added to 2.7.15,
3.6.3 and 3.7.0 for backwards compatibility with OpenSSL 1.0.2.
Disable all renegotiation in TLSv1.2 and earlier. Do not send
HelloRequest messages, and ignore renegotiation requests via ClientHello.
This option is only available with OpenSSL 1.1.0h and later.
3.7 新版功能.
Use the server's cipher ordering preference, rather than the client's.
This option has no effect on client sockets and SSLv2 server sockets.
3.3 新版功能.
Prevents re-use of the same DH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.
3.3 新版功能.
Prevents re-use of the same ECDH key for distinct SSL sessions.  This
improves forward secrecy but requires more computational resources.
This option only applies to server sockets.
3.3 新版功能.
Send dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make
a TLS 1.3 connection look more like a TLS 1.2 connection.
This option is only available with OpenSSL 1.1.1 and later.
3.8 新版功能.
Disable compression on the SSL channel.  This is useful if the application
protocol supports its own compression scheme.
This option is only available with OpenSSL 1.0.0 and later.
3.3 新版功能.
enum.IntFlag collection of OP_* constants.
Prevent client side from requesting a session ticket.
3.6 新版功能.
Whether the OpenSSL library has built-in support for the Application-Layer
Protocol Negotiation TLS extension as described in RFC 7301.
3.5 新版功能.
Whether the OpenSSL library has built-in support not checking subject
common name and SSLContext.hostname_checks_common_name is
writeable.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the Elliptic Curve-based
Diffie-Hellman key exchange.  This should be true unless the feature was
explicitly disabled by the distributor.
3.3 新版功能.
Whether the OpenSSL library has built-in support for the Server Name
Indication extension (as defined in RFC 6066).
3.2 新版功能.
Whether the OpenSSL library has built-in support for the Next Protocol
Negotiation as described in the Application Layer Protocol
Negotiation.
When true, you can use the SSLContext.set_npn_protocols() method to advertise
which protocols you want to support.
3.3 新版功能.
Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.
3.7 新版功能.
Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.
3.7 新版功能.
List of supported TLS channel binding types.  Strings in this list
can be used as arguments to SSLSocket.get_channel_binding().
3.3 新版功能.
The version string of the OpenSSL library loaded by the interpreter:
3.2 新版功能.
A tuple of five integers representing version information about the
OpenSSL library:
3.2 新版功能.
The raw version number of the OpenSSL library, as a single integer:
3.2 新版功能.
Alert Descriptions from RFC 5246 and others. The IANA TLS Alert Registry
contains this list and references to the RFCs where their meaning is defined.
Used as the return value of the callback function in
SSLContext.set_servername_callback().
3.4 新版功能.
enum.IntEnum collection of ALERT_DESCRIPTION_* constants.
3.6 新版功能.
Option for create_default_context() and
SSLContext.load_default_certs().  This value indicates that the
context may be used to authenticate Web servers (therefore, it will
be used to create client-side sockets).
3.4 新版功能.
Option for create_default_context() and
SSLContext.load_default_certs().  This value indicates that the
context may be used to authenticate Web clients (therefore, it will
be used to create server-side sockets).
3.4 新版功能.
enum.IntEnum collection of SSL_ERROR_* constants.
3.6 新版功能.
enum.IntEnum collection of SSL and TLS versions for
SSLContext.maximum_version and SSLContext.minimum_version.
3.7 新版功能.
The minimum or maximum supported SSL or TLS version. These are magic
constants. Their values don't reflect the lowest and highest available
TLS/SSL versions.
SSL 3.0 to TLS 1.3.
SSL sockets provide the following methods of 套接字对象:
accept()
bind()
close()
connect()
detach()
fileno()
getpeername(), getsockname()
getsockopt(), setsockopt()
gettimeout(), settimeout(),
setblocking()
listen()
makefile()
recv(), recv_into()
(but passing a non-zero flags argument is not allowed)
send(), sendall() (with
the same limitation)
sendfile() (but os.sendfile will be used
for plain-text sockets only, else send() will be used)
shutdown()
However, since the SSL (and TLS) protocol has its own framing atop
of TCP, the SSL sockets abstraction can, in certain respects, diverge from
the specification of normal, OS-level sockets.  See especially the
notes on non-blocking sockets.
Instances of SSLSocket must be created using the
SSLContext.wrap_socket() method.
在 3.5 版更改: The sendfile() method was added.
在 3.5 版更改: The shutdown() does not reset the socket timeout each time bytes
are received or sent. The socket timeout is now to maximum total duration
of the shutdown.
3.6 版后已移除: It is deprecated to create a SSLSocket instance directly, use
SSLContext.wrap_socket() to wrap a socket.
在 3.7 版更改: SSLSocket instances must to created with
wrap_socket(). In earlier versions, it was possible
to create instances directly. This was never documented or officially
supported.
SSL sockets also have the following additional methods and attributes:
Read up to len bytes of data from the SSL socket and return the result as
a bytes instance. If buffer is specified, then read into the buffer
instead, and return the number of bytes read.
Raise SSLWantReadError or SSLWantWriteError if the socket is
non-blocking and the read would block.
As at any time a re-negotiation is possible, a call to read() can also
cause write operations.
在 3.5 版更改: The socket timeout is no more reset each time bytes are received or sent.
The socket timeout is now to maximum total duration to read up to len
bytes.
3.6 版后已移除: Use recv() instead of read().
Write buf to the SSL socket and return the number of bytes written. The
buf argument must be an object supporting the buffer interface.
Raise SSLWantReadError or SSLWantWriteError if the socket is
non-blocking and the write would block.
As at any time a re-negotiation is possible, a call to write() can
also cause read operations.
在 3.5 版更改: The socket timeout is no more reset each time bytes are received or sent.
The socket timeout is now to maximum total duration to write buf.
3.6 版后已移除: Use send() instead of write().
注解
The read() and write() methods are the
low-level methods that read and write unencrypted, application-level data
and decrypt/encrypt it to encrypted, wire-level data. These methods
require an active SSL connection, i.e. the handshake was completed and
SSLSocket.unwrap() was not called.
Normally you should use the socket API methods like
recv() and send() instead of these
methods.
Perform the SSL setup handshake.
在 3.4 版更改: The handshake method also performs match_hostname() when the
check_hostname attribute of the socket's
context is true.
在 3.5 版更改: The socket timeout is no more reset each time bytes are received or sent.
The socket timeout is now to maximum total duration of the handshake.
在 3.7 版更改: Hostname or IP address is matched by OpenSSL during handshake. The
function match_hostname() is no longer used. In case OpenSSL
refuses a hostname or IP address, the handshake is aborted early and
a TLS alert message is send to the peer.
If there is no certificate for the peer on the other end of the connection,
return None.  If the SSL handshake hasn't been done yet, raise
ValueError.
If the binary_form parameter is False, and a certificate was
received from the peer, this method returns a dict instance.  If the
certificate was not validated, the dict is empty.  If the certificate was
validated, it returns a dict with several keys, amongst them subject
(the principal for which the certificate was issued) and issuer
(the principal issuing the certificate).  If a certificate contains an
instance of the Subject Alternative Name extension (see RFC 3280),
there will also be a subjectAltName key in the dictionary.
The subject and issuer fields are tuples containing the sequence
of relative distinguished names (RDNs) given in the certificate's data
structure for the respective fields, and each RDN is a sequence of
name-value pairs.  Here is a real-world example:
注解
To validate a certificate for a particular service, you can use the
match_hostname() function.
If the binary_form parameter is True, and a certificate was
provided, this method returns the DER-encoded form of the entire certificate
as a sequence of bytes, or None if the peer did not provide a
certificate.  Whether the peer provides a certificate depends on the SSL
socket's role:
for a client SSL socket, the server will always provide a certificate,
regardless of whether validation was required;
for a server SSL socket, the client will only provide a certificate
when requested by the server; therefore getpeercert() will return
None if you used CERT_NONE (rather than
CERT_OPTIONAL or CERT_REQUIRED).
在 3.2 版更改: The returned dictionary includes additional items such as issuer
and notBefore.
在 3.4 版更改: ValueError is raised when the handshake isn't done.
The returned dictionary includes additional X509v3 extension items
  such as crlDistributionPoints, caIssuers and OCSP URIs.
在 3.8.1 版更改: IPv6 address strings no longer have a trailing new line.
Returns a three-value tuple containing the name of the cipher being used, the
version of the SSL protocol that defines its use, and the number of secret
bits being used.  If no connection has been established, returns None.
Return the list of ciphers shared by the client during the handshake.  Each
entry of the returned list is a three-value tuple containing the name of the
cipher, the version of the SSL protocol that defines its use, and the number
of secret bits the cipher uses.  shared_ciphers() returns
None if no connection has been established or the socket is a client
socket.
3.5 新版功能.
Return the compression algorithm being used as a string, or None
if the connection isn't compressed.
If the higher-level protocol supports its own compression mechanism,
you can use OP_NO_COMPRESSION to disable SSL-level compression.
3.3 新版功能.
Get channel binding data for current connection, as a bytes object.  Returns
None if not connected or the handshake has not been completed.
The cb_type parameter allow selection of the desired channel binding
type. Valid channel binding types are listed in the
CHANNEL_BINDING_TYPES list.  Currently only the 'tls-unique' channel
binding, defined by RFC 5929, is supported.  ValueError will be
raised if an unsupported channel binding type is requested.
3.3 新版功能.
Return the protocol that was selected during the TLS handshake.  If
SSLContext.set_alpn_protocols() was not called, if the other party does
not support ALPN, if this socket does not support any of the client's
proposed protocols, or if the handshake has not happened yet, None is
returned.
3.5 新版功能.
Return the higher-level protocol that was selected during the TLS/SSL
handshake. If SSLContext.set_npn_protocols() was not called, or
if the other party does not support NPN, or if the handshake has not yet
happened, this will return None.
3.3 新版功能.
Performs the SSL shutdown handshake, which removes the TLS layer from the
underlying socket, and returns the underlying socket object.  This can be
used to go from encrypted operation over a connection to unencrypted.  The
returned socket should always be used for further communication with the
other side of the connection, rather than the original socket.
Requests post-handshake authentication (PHA) from a TLS 1.3 client. PHA
can only be initiated for a TLS 1.3 connection from a server-side socket,
after the initial TLS handshake and with PHA enabled on both sides, see
SSLContext.post_handshake_auth.
The method does not perform a cert exchange immediately. The server-side
sends a CertificateRequest during the next write event and expects the
client to respond with a certificate on the next read event.
If any precondition isn't met (e.g. not TLS 1.3, PHA not enabled), an
SSLError is raised.
注解
Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the method raises NotImplementedError.
3.8 新版功能.
Return the actual SSL protocol version negotiated by the connection
as a string, or None is no secure connection is established.
As of this writing, possible return values include "SSLv2",
"SSLv3", "TLSv1", "TLSv1.1" and "TLSv1.2".
Recent OpenSSL versions may define more return values.
3.5 新版功能.
Returns the number of already decrypted bytes available for read, pending on
the connection.
The SSLContext object this SSL socket is tied to.  If the SSL
socket was created using the deprecated wrap_socket() function
(rather than SSLContext.wrap_socket()), this is a custom context
object created for this SSL socket.
3.2 新版功能.
A boolean which is True for server-side sockets and False for
client-side sockets.
3.2 新版功能.
Hostname of the server: str type, or None for server-side
socket or if the hostname was not specified in the constructor.
3.2 新版功能.
在 3.7 版更改: The attribute is now always ASCII text. When server_hostname is
an internationalized domain name (IDN), this attribute now stores the
A-label form ("xn--pythn-mua.org"), rather than the U-label form
("pythön.org").
The SSLSession for this SSL connection. The session is available
for client and server side sockets after the TLS handshake has been
performed. For client sockets the session can be set before
do_handshake() has been called to reuse a session.
3.6 新版功能.
3.6 新版功能.
3.2 新版功能.
An SSL context holds various data longer-lived than single SSL connections,
such as SSL configuration options, certificate(s) and private key(s).
It also manages a cache of SSL sessions for server-side sockets, in order
to speed up repeated connections from the same clients.
Create a new SSL context.  You may pass protocol which must be one
of the PROTOCOL_* constants defined in this module.  The parameter
specifies which version of the SSL protocol to use.  Typically, the
server chooses a particular protocol version, and the client must adapt
to the server's choice.  Most of the versions are not interoperable
with the other versions.  If not specified, the default is
PROTOCOL_TLS; it provides the most compatibility with other
versions.
Here's a table showing which versions in a client (down the side) can connect
to which versions in a server (along the top):
客户端 / 服务器
SSLv2
SSLv3
TLS 3
TLSv1
TLSv1.1
TLSv1.2
SSLv2
是
否
否 1
否
否
否
SSLv3
否
是
否 2
否
否
否
TLS (SSLv23) 3
否 1
否 2
是
是
是
是
TLSv1
否
否
是
是
否
否
TLSv1.1
否
否
是
否
是
否
TLSv1.2
否
否
是
否
否
是
备注
SSLContext disables SSLv2 with OP_NO_SSLv2 by default.
SSLContext disables SSLv3 with OP_NO_SSLv3 by default.
TLS 1.3 protocol will be available with PROTOCOL_TLS in
OpenSSL &gt;= 1.1.1. There is no dedicated PROTOCOL constant for just
TLS 1.3.
参见
create_default_context() lets the ssl module choose
security settings for a given purpose.
在 3.6 版更改: The context is created with secure default values. The options
OP_NO_COMPRESSION, OP_CIPHER_SERVER_PREFERENCE,
OP_SINGLE_DH_USE, OP_SINGLE_ECDH_USE,
OP_NO_SSLv2 (except for PROTOCOL_SSLv2),
and OP_NO_SSLv3 (except for PROTOCOL_SSLv3) are
set by default. The initial cipher suite list contains only HIGH
ciphers, no NULL ciphers and no MD5 ciphers (except for
PROTOCOL_SSLv2).
SSLContext objects have the following methods and attributes:
Get statistics about quantities of loaded X.509 certificates, count of
X.509 certificates flagged as CA certificates and certificate revocation
lists as dictionary.
Example for a context with one CA cert and one other cert:
3.4 新版功能.
Load a private key and the corresponding certificate.  The certfile
string must be the path to a single file in PEM format containing the
certificate as well as any number of CA certificates needed to establish
the certificate's authenticity.  The keyfile string, if present, must
point to a file containing the private key in.  Otherwise the private
key will be taken from certfile as well.  See the discussion of
Certificates for more information on how the certificate
is stored in the certfile.
The password argument may be a function to call to get the password for
decrypting the private key.  It will only be called if the private key is
encrypted and a password is necessary.  It will be called with no arguments,
and it should return a string, bytes, or bytearray.  If the return value is
a string it will be encoded as UTF-8 before using it to decrypt the key.
Alternatively a string, bytes, or bytearray value may be supplied directly
as the password argument.  It will be ignored if the private key is not
encrypted and no password is needed.
If the password argument is not specified and a password is required,
OpenSSL's built-in password prompting mechanism will be used to
interactively prompt the user for a password.
An SSLError is raised if the private key doesn't
match with the certificate.
在 3.3 版更改: New optional argument password.
Load a set of default "certification authority" (CA) certificates from
default locations. On Windows it loads CA certs from the CA and
ROOT system stores. On other systems it calls
SSLContext.set_default_verify_paths(). In the future the method may
load CA certificates from other locations, too.
The purpose flag specifies what kind of CA certificates are loaded. The
default settings Purpose.SERVER_AUTH loads certificates, that are
flagged and trusted for TLS web server authentication (client side
sockets). Purpose.CLIENT_AUTH loads CA certificates for client
certificate verification on the server side.
3.4 新版功能.
Load a set of "certification authority" (CA) certificates used to validate
other peers' certificates when verify_mode is other than
CERT_NONE.  At least one of cafile or capath must be specified.
This method can also load certification revocation lists (CRLs) in PEM or
DER format. In order to make use of CRLs, SSLContext.verify_flags
must be configured properly.
The cafile string, if present, is the path to a file of concatenated
CA certificates in PEM format. See the discussion of
Certificates for more information about how to arrange the
certificates in this file.
The capath string, if present, is
the path to a directory containing several CA certificates in PEM format,
following an OpenSSL specific layout.
The cadata object, if present, is either an ASCII string of one or more
PEM-encoded certificates or a bytes-like object of DER-encoded
certificates. Like with capath extra lines around PEM-encoded
certificates are ignored but at least one certificate must be present.
在 3.4 版更改: New optional argument cadata
Get a list of loaded "certification authority" (CA) certificates. If the
binary_form parameter is False each list
entry is a dict like the output of SSLSocket.getpeercert(). Otherwise
the method returns a list of DER-encoded certificates. The returned list
does not contain certificates from capath unless a certificate was
requested and loaded by a SSL connection.
注解
Certificates in a capath directory aren't loaded unless they have
been used at least once.
3.4 新版功能.
Get a list of enabled ciphers. The list is in order of cipher priority.
See SSLContext.set_ciphers().
示例:
On OpenSSL 1.1 and newer the cipher dict contains additional fields:
Availability: OpenSSL 1.0.2+.
3.6 新版功能.
Load a set of default "certification authority" (CA) certificates from
a filesystem path defined when building the OpenSSL library.  Unfortunately,
there's no easy way to know whether this method succeeds: no error is
returned if no certificates are to be found.  When the OpenSSL library is
provided as part of the operating system, though, it is likely to be
configured properly.
Set the available ciphers for sockets created with this context.
It should be a string in the OpenSSL cipher list format.
If no cipher can be selected (because compile-time options or other
configuration forbids use of all the specified ciphers), an
SSLError will be raised.
注解
when connected, the SSLSocket.cipher() method of SSL sockets will
give the currently selected cipher.
OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites
cannot be disabled with set_ciphers().
Specify which protocols the socket should advertise during the SSL/TLS
handshake. It should be a list of ASCII strings, like ['http/1.1',
'spdy/2'], ordered by preference. The selection of a protocol will happen
during the handshake, and will play out according to RFC 7301. After a
successful handshake, the SSLSocket.selected_alpn_protocol() method will
return the agreed-upon protocol.
This method will raise NotImplementedError if HAS_ALPN is
False.
OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise SSLError
when both sides support ALPN but cannot agree on a protocol. 1.1.0f+
behaves like 1.0.2, SSLSocket.selected_alpn_protocol() returns None.
3.5 新版功能.
Specify which protocols the socket should advertise during the SSL/TLS
handshake. It should be a list of strings, like ['http/1.1', 'spdy/2'],
ordered by preference. The selection of a protocol will happen during the
handshake, and will play out according to the Application Layer Protocol Negotiation. After a
successful handshake, the SSLSocket.selected_npn_protocol() method will
return the agreed-upon protocol.
This method will raise NotImplementedError if HAS_NPN is
False.
3.3 新版功能.
Register a callback function that will be called after the TLS Client Hello
handshake message has been received by the SSL/TLS server when the TLS client
specifies a server name indication. The server name indication mechanism
is specified in RFC 6066 section 3 - Server Name Indication.
Only one callback can be set per SSLContext.  If sni_callback
is set to None then the callback is disabled. Calling this function a
subsequent time will disable the previously registered callback.
The callback function will be called with three
arguments; the first being the ssl.SSLSocket, the second is a string
that represents the server name that the client is intending to communicate
(or None if the TLS Client Hello does not contain a server name)
and the third argument is the original SSLContext. The server name
argument is text. For internationalized domain name, the server
name is an IDN A-label ("xn--pythn-mua.org").
A typical use of this callback is to change the ssl.SSLSocket's
SSLSocket.context attribute to a new object of type
SSLContext representing a certificate chain that matches the server
name.
Due to the early negotiation phase of the TLS connection, only limited
methods and attributes are usable like
SSLSocket.selected_alpn_protocol() and SSLSocket.context.
SSLSocket.getpeercert(), SSLSocket.getpeercert(),
SSLSocket.cipher() and SSLSocket.compress() methods require that
the TLS connection has progressed beyond the TLS Client Hello and therefore
will not contain return meaningful values nor can they be called safely.
The sni_callback function must return None to allow the
TLS negotiation to continue.  If a TLS failure is required, a constant
ALERT_DESCRIPTION_* can be
returned.  Other return values will result in a TLS fatal error with
ALERT_DESCRIPTION_INTERNAL_ERROR.
If an exception is raised from the sni_callback function the TLS
connection will terminate with a fatal TLS alert message
ALERT_DESCRIPTION_HANDSHAKE_FAILURE.
This method will raise NotImplementedError if the OpenSSL library
had OPENSSL_NO_TLSEXT defined when it was built.
3.7 新版功能.
This is a legacy API retained for backwards compatibility. When possible,
you should use sni_callback instead. The given server_name_callback
is similar to sni_callback, except that when the server hostname is an
IDN-encoded internationalized domain name, the server_name_callback
receives a decoded U-label ("pythön.org").
If there is an decoding error on the server name, the TLS connection will
terminate with an ALERT_DESCRIPTION_INTERNAL_ERROR fatal TLS
alert message to the client.
3.4 新版功能.
Load the key generation parameters for Diffie-Hellman (DH) key exchange.
Using DH key exchange improves forward secrecy at the expense of
computational resources (both on the server and on the client).
The dhfile parameter should be the path to a file containing DH
parameters in PEM format.
This setting doesn't apply to client sockets.  You can also use the
OP_SINGLE_DH_USE option to further improve security.
3.3 新版功能.
Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key
exchange.  ECDH is significantly faster than regular DH while arguably
as secure.  The curve_name parameter should be a string describing
a well-known elliptic curve, for example prime256v1 for a widely
supported curve.
This setting doesn't apply to client sockets.  You can also use the
OP_SINGLE_ECDH_USE option to further improve security.
This method is not available if HAS_ECDH is False.
3.3 新版功能.
参见
Vincent Bernat.
Wrap an existing Python socket sock and return an instance of
SSLContext.sslsocket_class (default SSLSocket). The
returned SSL socket is tied to the context, its settings and certificates.
sock must be a SOCK_STREAM socket; other
socket types are unsupported.
The parameter server_side is a boolean which identifies whether
server-side or client-side behavior is desired from this socket.
For client-side sockets, the context construction is lazy; if the
underlying socket isn't connected yet, the context construction will be
performed after connect() is called on the socket.  For
server-side sockets, if the socket has no remote peer, it is assumed
to be a listening socket, and the server-side SSL wrapping is
automatically performed on client connections accepted via the
accept() method. The method may raise SSLError.
On client connections, the optional parameter server_hostname specifies
the hostname of the service which we are connecting to.  This allows a
single server to host multiple SSL-based services with distinct certificates,
quite similarly to HTTP virtual hosts. Specifying server_hostname will
raise a ValueError if server_side is true.
The parameter do_handshake_on_connect specifies whether to do the SSL
handshake automatically after doing a socket.connect(), or whether the
application program will call it explicitly, by invoking the
SSLSocket.do_handshake() method.  Calling
SSLSocket.do_handshake() explicitly gives the program control over the
blocking behavior of the socket I/O involved in the handshake.
The parameter suppress_ragged_eofs specifies how the
SSLSocket.recv() method should signal unexpected EOF from the other end
of the connection.  If specified as True (the default), it returns a
normal EOF (an empty bytes object) in response to unexpected EOF errors
raised from the underlying socket; if False, it will raise the
exceptions back to the caller.
session, see session.
在 3.5 版更改: Always allow a server_hostname to be passed, even if OpenSSL does not
have SNI.
在 3.6 版更改: session argument was added.
在 3.7 版更改: The method returns on instance of SSLContext.sslsocket_class
instead of hard-coded SSLSocket.
The return type of SSLContext.wrap_socket(), defaults to
SSLSocket. The attribute can be overridden on instance of class
in order to return a custom subclass of SSLSocket.
3.7 新版功能.
Wrap the BIO objects incoming and outgoing and return an instance of
SSLContext.sslobject_class (default SSLObject). The SSL
routines will read input data from the incoming BIO and write data to the
outgoing BIO.
The server_side, server_hostname and session parameters have the
same meaning as in SSLContext.wrap_socket().
在 3.6 版更改: session argument was added.
在 3.7 版更改: The method returns on instance of SSLContext.sslobject_class
instead of hard-coded SSLObject.
The return type of SSLContext.wrap_bio(), defaults to
SSLObject. The attribute can be overridden on instance of class
in order to return a custom subclass of SSLObject.
3.7 新版功能.
Get statistics about the SSL sessions created or managed by this context.
A dictionary is returned which maps the names of each piece of information to their
numeric values.  For example, here is the total number of hits and misses
in the session cache since the context was created:
Whether to match the peer cert's hostname with match_hostname() in
SSLSocket.do_handshake(). The context's
verify_mode must be set to CERT_OPTIONAL or
CERT_REQUIRED, and you must pass server_hostname to
wrap_socket() in order to match the hostname.  Enabling
hostname checking automatically sets verify_mode from
CERT_NONE to CERT_REQUIRED.  It cannot be set back to
CERT_NONE as long as hostname checking is enabled. The
PROTOCOL_TLS_CLIENT protocol enables hostname checking by default.
With other protocols, hostname checking must be enabled explicitly.
示例:
3.4 新版功能.
在 3.7 版更改: verify_mode is now automatically changed
to CERT_REQUIRED  when hostname checking is enabled and
verify_mode is CERT_NONE. Previously
the same operation would have failed with a ValueError.
注解
This features requires OpenSSL 0.9.8f or newer.
Write TLS keys to a keylog file, whenever key material is generated or
received. The keylog file is designed for debugging purposes only. The
file format is specified by NSS and used by many traffic analyzers such
as Wireshark. The log file is opened in append-only mode. Writes are
synchronized between threads, but not between processes.
3.8 新版功能.
注解
This features requires OpenSSL 1.1.1 or newer.
A TLSVersion enum member representing the highest supported
TLS version. The value defaults to TLSVersion.MAXIMUM_SUPPORTED.
The attribute is read-only for protocols other than PROTOCOL_TLS,
PROTOCOL_TLS_CLIENT, and PROTOCOL_TLS_SERVER.
The attributes maximum_version,
minimum_version and
SSLContext.options all affect the supported SSL
and TLS versions of the context. The implementation does not prevent
invalid combination. For example a context with
OP_NO_TLSv1_2 in options and
maximum_version set to TLSVersion.TLSv1_2
will not be able to establish a TLS 1.2 connection.
注解
This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.0g or newer.
3.7 新版功能.
Like SSLContext.maximum_version except it is the lowest
supported version or TLSVersion.MINIMUM_SUPPORTED.
注解
This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.0g or newer.
3.7 新版功能.
Control the number of TLS 1.3 session tickets of a
TLS_PROTOCOL_SERVER context. The setting has no impact on TLS
1.0 to 1.2 connections.
注解
This attribute is not available unless the ssl module is compiled
with OpenSSL 1.1.1 or newer.
3.8 新版功能.
An integer representing the set of SSL options enabled on this context.
The default value is OP_ALL, but you can specify other options
such as OP_NO_SSLv2 by ORing them together.
注解
With versions of OpenSSL older than 0.9.8m, it is only possible
to set options, not to clear them.  Attempting to clear an option
(by resetting the corresponding bits) will raise a ValueError.
在 3.6 版更改: SSLContext.options returns Options flags:
Enable TLS 1.3 post-handshake client authentication. Post-handshake auth
is disabled by default and a server can only request a TLS client
certificate during the initial handshake. When enabled, a server may
request a TLS client certificate at any time after the handshake.
When enabled on client-side sockets, the client signals the server that
it supports post-handshake authentication.
When enabled on server-side sockets, SSLContext.verify_mode must
be set to CERT_OPTIONAL or CERT_REQUIRED, too. The
actual client cert exchange is delayed until
SSLSocket.verify_client_post_handshake() is called and some I/O is
performed.
注解
Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3
support, the property value is None and can't be modified
3.8 新版功能.
The protocol version chosen when constructing the context.  This attribute
is read-only.
Whether check_hostname falls back to verify the cert's
subject common name in the absence of a subject alternative name
extension (default: true).
注解
Only writeable with OpenSSL 1.1.0 or higher.
3.7 新版功能.
The flags for certificate verification operations. You can set flags like
VERIFY_CRL_CHECK_LEAF by ORing them together. By default OpenSSL
does neither require nor verify certificate revocation lists (CRLs).
Available only with openssl version 0.9.8+.
3.4 新版功能.
在 3.6 版更改: SSLContext.verify_flags returns VerifyFlags flags:
Whether to try to verify other peers' certificates and how to behave
if verification fails.  This attribute must be one of
CERT_NONE, CERT_OPTIONAL or CERT_REQUIRED.
在 3.6 版更改: SSLContext.verify_mode returns VerifyMode enum:
Certificates in general are part of a public-key / private-key system.  In this
system, each principal, (which may be a machine, or a person, or an
organization) is assigned a unique two-part encryption key.  One part of the key
is public, and is called the public key; the other part is kept secret, and is
called the private key.  The two parts are related, in that if you encrypt a
message with one of the parts, you can decrypt it with the other part, and
only with the other part.
A certificate contains information about two principals.  It contains the name
of a subject, and the subject's public key.  It also contains a statement by a
second principal, the issuer, that the subject is who they claim to be, and
that this is indeed the subject's public key.  The issuer's statement is signed
with the issuer's private key, which only the issuer knows.  However, anyone can
verify the issuer's statement by finding the issuer's public key, decrypting the
statement with it, and comparing it to the other information in the certificate.
The certificate also contains information about the time period over which it is
valid.  This is expressed as two fields, called "notBefore" and "notAfter".
In the Python use of certificates, a client or server can use a certificate to
prove who they are.  The other side of a network connection can also be required
to produce a certificate, and that certificate can be validated to the
satisfaction of the client or server that requires such validation.  The
connection attempt can be set to raise an exception if the validation fails.
Validation is done automatically, by the underlying OpenSSL framework; the
application need not concern itself with its mechanics.  But the application
does usually need to provide sets of certificates to allow this process to take
place.
Python uses files to contain certificates.  They should be formatted as "PEM"
(see RFC 1422), which is a base-64 encoded form wrapped with a header line
and a footer line:
The Python files which contain certificates can contain a sequence of
certificates, sometimes called a certificate chain.  This chain should start
with the specific certificate for the principal who "is" the client or server,
and then the certificate for the issuer of that certificate, and then the
certificate for the issuer of that certificate, and so on up the chain till
you get to a certificate which is self-signed, that is, a certificate which
has the same subject and issuer, sometimes called a root certificate.  The
certificates should just be concatenated together in the certificate file.  For
example, suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority's certificate:
If you are going to require validation of the other side of the connection's
certificate, you need to provide a "CA certs" file, filled with the certificate
chains for each issuer you are willing to trust.  Again, this file just contains
these chains concatenated together.  For validation, Python will use the first
chain it finds in the file which matches.  The platform's certificates file can
be used by calling SSLContext.load_default_certs(), this is done
automatically with create_default_context().
Often the private key is stored in the same file as the certificate; in this
case, only the certfile parameter to SSLContext.load_cert_chain()
and wrap_socket() needs to be passed.  If the private key is stored
with the certificate, it should come before the first certificate in
the certificate chain:
If you are going to create a server that provides SSL-encrypted connection
services, you will need to acquire a certificate for that service.  There are
many ways of acquiring appropriate certificates, such as buying one from a
certification authority.  Another common practice is to generate a self-signed
certificate.  The simplest way to do this is with the OpenSSL package, using
something like the following:
The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and trusted)
root certificates.
To test for the presence of SSL support in a Python installation, user code
should use the following idiom:
This example creates a SSL context with the recommended security settings
for client sockets, including automatic certificate verification:
If you prefer to tune security settings yourself, you might create
a context from scratch (but beware that you might not get the settings
right):
(this snippet assumes your operating system places a bundle of all CA
certificates in /etc/ssl/certs/ca-bundle.crt; if not, you'll get an
error and have to adjust the location)
The PROTOCOL_TLS_CLIENT protocol configures the context for cert
validation and hostname verification. verify_mode is
set to CERT_REQUIRED and check_hostname is set
to True. All other protocols create SSL contexts with insecure defaults.
When you use the context to connect to a server, CERT_REQUIRED
and check_hostname validate the server certificate: it
ensures that the server certificate was signed with one of the CA
certificates, checks the signature for correctness, and verifies other
properties like validity and identity of the hostname:
You may then fetch the certificate:
Visual inspection shows that the certificate does identify the desired service
(that is, the HTTPS host www.python.org):
Now the SSL channel is established and the certificate verified, you can
proceed to talk with the server:
See the discussion of Security considerations below.
For server operation, typically you'll need to have a server certificate, and
private key, each in a file.  You'll first create a context holding the key
and the certificate, so that clients can check your authenticity.  Then
you'll open a socket, bind it to a port, call listen() on it, and start
waiting for clients to connect:
When a client connects, you'll call accept() on the socket to get the
new socket from the other end, and use the context's SSLContext.wrap_socket()
method to create a server-side SSL socket for the connection:
Then you'll read data from the connstream and do something with it till you
are finished with the client (or the client is finished with you):
And go back to listening for new client connections (of course, a real server
would probably handle each client connection in a separate thread, or put
the sockets in non-blocking mode and use an event loop).
SSL sockets behave slightly different than regular sockets in
non-blocking mode. When working with non-blocking sockets, there are
thus several things you need to be aware of:
Most SSLSocket methods will raise either
SSLWantWriteError or SSLWantReadError instead of
BlockingIOError if an I/O operation would
block. SSLWantReadError will be raised if a read operation on
the underlying socket is necessary, and SSLWantWriteError for
a write operation on the underlying socket. Note that attempts to
write to an SSL socket may require reading from the underlying
socket first, and attempts to read from the SSL socket may require
a prior write to the underlying socket.
在 3.5 版更改: In earlier Python versions, the SSLSocket.send() method
returned zero instead of raising SSLWantWriteError or
SSLWantReadError.
Calling select() tells you that the OS-level socket can be
read from (or written to), but it does not imply that there is sufficient
data at the upper SSL layer.  For example, only part of an SSL frame might
have arrived.  Therefore, you must be ready to handle SSLSocket.recv()
and SSLSocket.send() failures, and retry after another call to
select().
Conversely, since the SSL layer has its own framing, a SSL socket may
still have data available for reading without select()
being aware of it.  Therefore, you should first call
SSLSocket.recv() to drain any potentially available data, and then
only block on a select() call if still necessary.
(of course, similar provisions apply when using other primitives such as
poll(), or those in the selectors module)
The SSL handshake itself will be non-blocking: the
SSLSocket.do_handshake() method has to be retried until it returns
successfully.  Here is a synopsis using select() to wait for
the socket's readiness:
参见
The asyncio module supports non-blocking SSL sockets and provides a
higher level API. It polls for events using the selectors module and
handles SSLWantWriteError, SSLWantReadError and
BlockingIOError exceptions. It runs the SSL handshake asynchronously
as well.
3.5 新版功能.
Ever since the SSL module was introduced in Python 2.6, the SSLSocket
class has provided two related but distinct areas of functionality:
SSL protocol handling
Network IO
The network IO API is identical to that provided by socket.socket,
from which SSLSocket also inherits. This allows an SSL socket to be
used as a drop-in replacement for a regular socket, making it very easy to add
SSL support to an existing application.
Combining SSL protocol handling and network IO usually works well, but there
are some cases where it doesn't. An example is async IO frameworks that want to
use a different IO multiplexing model than the "select/poll on a file
descriptor" (readiness based) model that is assumed by socket.socket
and by the internal OpenSSL socket IO routines. This is mostly relevant for
platforms like Windows where this model is not efficient. For this purpose, a
reduced scope variant of SSLSocket called SSLObject is
provided.
A reduced-scope variant of SSLSocket representing an SSL protocol
instance that does not contain any network IO methods. This class is
typically used by framework authors that want to implement asynchronous IO
for SSL through memory buffers.
This class implements an interface on top of a low-level SSL object as
implemented by OpenSSL. This object captures the state of an SSL connection
but does not provide any network IO itself. IO needs to be performed through
separate "BIO" objects which are OpenSSL's IO abstraction layer.
This class has no public constructor.  An SSLObject instance
must be created using the wrap_bio() method. This
method will create the SSLObject instance and bind it to a
pair of BIOs. The incoming BIO is used to pass data from Python to the
SSL protocol instance, while the outgoing BIO is used to pass data the
other way around.
可以使用以下方法：
context
server_side
server_hostname
session
session_reused
read()
write()
getpeercert()
selected_alpn_protocol()
selected_npn_protocol()
cipher()
shared_ciphers()
compression()
pending()
do_handshake()
verify_client_post_handshake()
unwrap()
get_channel_binding()
version()
When compared to SSLSocket, this object lacks the following
features:
Any form of network IO; recv() and send() read and write only to
the underlying MemoryBIO buffers.
There is no do_handshake_on_connect machinery. You must always manually
call do_handshake() to start the handshake.
There is no handling of suppress_ragged_eofs. All end-of-file conditions
that are in violation of the protocol are reported via the
SSLEOFError exception.
The method unwrap() call does not return anything,
unlike for an SSL socket where it returns the underlying socket.
The server_name_callback callback passed to
SSLContext.set_servername_callback() will get an SSLObject
instance instead of a SSLSocket instance as its first parameter.
Some notes related to the use of SSLObject:
All IO on an SSLObject is non-blocking.
This means that for example read() will raise an
SSLWantReadError if it needs more data than the incoming BIO has
available.
There is no module-level wrap_bio() call like there is for
wrap_socket(). An SSLObject is always created
via an SSLContext.
在 3.7 版更改: SSLObject instances must to created with
wrap_bio(). In earlier versions, it was possible to
create instances directly. This was never documented or officially
supported.
An SSLObject communicates with the outside world using memory buffers. The
class MemoryBIO provides a memory buffer that can be used for this
purpose.  It wraps an OpenSSL memory BIO (Basic IO) object:
A memory buffer that can be used to pass data between Python and an SSL
protocol instance.
Return the number of bytes currently in the memory buffer.
A boolean indicating whether the memory BIO is current at the end-of-file
position.
Read up to n bytes from the memory buffer. If n is not specified or
negative, all bytes are returned.
Write the bytes from buf to the memory BIO. The buf argument must be an
object supporting the buffer protocol.
The return value is the number of bytes written, which is always equal to
the length of buf.
Write an EOF marker to the memory BIO. After this method has been called, it
is illegal to call write(). The attribute eof will
become true after all data currently in the buffer has been read.
3.6 新版功能.
Session object used by session.
For client use, if you don't have any special requirements for your
security policy, it is highly recommended that you use the
create_default_context() function to create your SSL context.
It will load the system's trusted CA certificates, enable certificate
validation and hostname checking, and try to choose reasonably secure
protocol and cipher settings.
For example, here is how you would use the smtplib.SMTP class to
create a trusted, secure connection to a SMTP server:
If a client certificate is needed for the connection, it can be added with
SSLContext.load_cert_chain().
By contrast, if you create the SSL context by calling the SSLContext
constructor yourself, it will not have certificate validation nor hostname
checking enabled by default.  If you do so, please read the paragraphs below
to achieve a good security level.
When calling the SSLContext constructor directly,
CERT_NONE is the default.  Since it does not authenticate the other
peer, it can be insecure, especially in client mode where most of time you
would like to ensure the authenticity of the server you're talking to.
Therefore, when in client mode, it is highly recommended to use
CERT_REQUIRED.  However, it is in itself not sufficient; you also
have to check that the server certificate, which can be obtained by calling
SSLSocket.getpeercert(), matches the desired service.  For many
protocols and applications, the service can be identified by the hostname;
in this case, the match_hostname() function can be used.  This common
check is automatically performed when SSLContext.check_hostname is
enabled.
在 3.7 版更改: Hostname matchings is now performed by OpenSSL. Python no longer uses
match_hostname().
In server mode, if you want to authenticate your clients using the SSL layer
(rather than using a higher-level authentication mechanism), you'll also have
to specify CERT_REQUIRED and similarly check the client certificate.
SSL versions 2 and 3 are considered insecure and are therefore dangerous to
use.  If you want maximum compatibility between clients and servers, it is
recommended to use PROTOCOL_TLS_CLIENT or
PROTOCOL_TLS_SERVER as the protocol version. SSLv2 and SSLv3 are
disabled by default.
The SSL context created above will only allow TLSv1.2 and later (if
supported by your system) connections to a server. PROTOCOL_TLS_CLIENT
implies certificate validation and hostname checks by default. You have to
load certificates into the context.
If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the
SSLContext.set_ciphers() method.  Starting from Python 3.2.3, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL's documentation
about the cipher list format.
If you want to check which ciphers are enabled by a given cipher list, use
SSLContext.get_ciphers() or the openssl ciphers command on your
system.
If using this module as part of a multi-processed application (using,
for example the multiprocessing or concurrent.futures modules),
be aware that OpenSSL's internal random number generator does not properly
handle forked processes.  Applications must change the PRNG state of the
parent process if they use any SSL feature with os.fork().  Any
successful call of RAND_add(), RAND_bytes() or
RAND_pseudo_bytes() is sufficient.
3.7 新版功能.
Python has provisional and experimental support for TLS 1.3 with OpenSSL
1.1.1.  The new protocol behaves slightly differently than previous version
of TLS/SSL.  Some new TLS 1.3 features are not yet available.
TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and
ChaCha20 cipher suites are enabled by default.  The method
SSLContext.set_ciphers() cannot enable or disable any TLS 1.3
ciphers yet, but SSLContext.get_ciphers() returns them.
Session tickets are no longer sent as part of the initial handshake and
are handled differently.  SSLSocket.session and SSLSession
are not compatible with TLS 1.3.
Client-side certificates are also no longer verified during the initial
handshake.  A server can request a certificate at any time.  Clients
process certificate requests while they send or receive application data
from the server.
TLS 1.3 features like early data, deferred TLS client cert request,
signature algorithm configuration, and rekeying are not supported yet.
LibreSSL is a fork of OpenSSL 1.0.1. The ssl module has limited support for
LibreSSL. Some features are not available when the ssl module is compiled
with LibreSSL.
LibreSSL &gt;= 2.6.1 no longer supports NPN. The methods
SSLContext.set_npn_protocols() and
SSLSocket.selected_npn_protocol() are not available.
SSLContext.set_default_verify_paths() ignores the env vars
SSL_CERT_FILE and SSL_CERT_PATH although
get_default_verify_paths() still reports them.
参见
Documentation of underlying socket class
Apache HTTP Server文档介绍
Steve Kent
Donald E., Jeffrey I. Schiller
D. Cooper
T. Dierks et. al.
D. Eastlake
IANA
IETF
Mozilla
socket --- 底层网络接口
select --- 等待 I/O 完成
</body></doc>