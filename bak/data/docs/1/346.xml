<?xml version='1.0' encoding='utf-8'?>
<doc><id>346</id><url>https://docs.python.org/zh-cn/3/library/atexit.html</url><title> --- 退出处理器</title><body>atexit 模块定义了清理函数的注册和反注册函数. 被注册的函数会在解释器正常终止时执行. atexit 会按照注册顺序的*逆序*执行; 如果你注册了 A, B 和 C, 那么在解释器终止时会依序执行 C, B, A.
注意: 通过该模块注册的函数, 在程序被未被 Python 捕获的信号杀死时并不会执行, 在检测到 Python 内部致命错误以及调用了 os._exit() 时也不会执行.
在 3.7 版更改: 当配合 C-API 子解释器使用时，已注册函数是它们所注册解释器中的局部对象。
将 func 注册为终止时执行的函数.  任何传给 func 的可选的参数都应当作为参数传给 register().  可以多次注册同样的函数及参数.
在正常的程序终止时 (举例来说, 当调用了 sys.exit() 或是主模块的执行完成时), 所有注册过的函数都会以后进先出的顺序执行. 这样做是假定更底层的模块通常会比高层模块更早引入, 因此需要更晚清理.
如果在 exit 处理程序执行期间引发了异常，将会打印回溯信息 (除非引发的是 SystemExit) 并且异常信息会被保存。 在所有 exit 处理程序获得运行机会之后，所引发的最后一个异常会被重新引发。
这个函数返回 func 对象，可以把它当作装饰器使用。
从解释器关闭前要运行的函数列表中移除 func。 在调用 unregister() 之后，当解释器关闭时会确保 func 不会被调用，即使它被多次注册。 如果 func 之前没有被注册，unregister() 会静默地不做任何操作。
参见
使用 atexit 读写 readline 历史文件的有用的例子。
以下简单例子演示了一个模块在被导入时如何从文件初始化一个计数器，并在程序终结时自动保存计数器的更新值，此操作不依赖于应用在终结时对此模块进行显式调用。:
位置和关键字参数也可传入 register() 以便传递给被调用的已注册函数:
作为 decorator: 使用:
只有在函数不需要任何参数调用时才能工作.
abc --- 抽象基类
traceback --- 打印或检索堆栈回溯
</body></doc>