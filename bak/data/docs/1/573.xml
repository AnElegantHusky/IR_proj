<?xml version='1.0' encoding='utf-8'?>
<doc><id>573</id><url>https://docs.python.org/zh-cn/3/library/typing.html</url><title> --- 类型标注支持</title><body>3.5 新版功能.
源码： Lib/typing.py
注解
The Python runtime does not enforce function and variable type annotations.
They can be used by third party tools such as type checkers, IDEs, linters,
etc.
This module provides runtime support for type hints as specified by
PEP 484, PEP 526, PEP 544, PEP 586, PEP 589, and PEP 591.
The most fundamental support consists of the types Any, Union,
Tuple, Callable, TypeVar, and
Generic.  For full specification please see PEP 484.  For
a simplified introduction to type hints see PEP 483.
函数接受并返回一个字符串，注释像下面这样:
在函数 greeting 中，参数 name 预期是 str 类型，并且返回 str 类型。子类型允许作为参数。
类型别名通过将类型分配给别名来定义。在这个例子中， Vector 和 List[float] 将被视为可互换的同义词:
类型别名可用于简化复杂类型签名。例如:
请注意，None 作为类型提示是一种特殊情况，并且由 type(None) 取代。
使用 NewType() 辅助函数创建不同的类型:
静态类型检查器会将新类型视为它是原始类型的子类。这对于帮助捕捉逻辑错误非常有用:
您仍然可以对 UserId 类型的变量执行所有的 int 支持的操作，但结果将始终为 int 类型。这可以让你在需要 int 的地方传入 UserId，但会阻止你以无效的方式无意中创建 UserId:
Note that these checks are enforced only by the static type checker. At runtime,
the statement Derived = NewType('Derived', Base) will make Derived a
function that immediately returns whatever parameter you pass it. That means
the expression Derived(some_value) does not create a new class or introduce
any overhead beyond that of a regular function call.
更确切地说，表达式 some_value is Derived(some_value) 在运行时总是为真。
这也意味着无法创建 Derived 的子类型，因为它是运行时的标识函数，而不是实际的类型:
但是，可以基于'derived' NewType 创建 NewType()
并且 ProUserId 的类型检查将按预期工作。
有关更多详细信息，请参阅 PEP 484。
注解
回想一下，使用类型别名声明两种类型彼此 等效 。Alias = Original 将使静态类型检查对待所有情况下 Alias 完全等同于 Original。当您想简化复杂类型签名时，这很有用。
相反，NewType 声明一种类型是另一种类型的子类型。Derived = NewType('Derived', Original) 将使静态类型检查器将 Derived 当作 Original 的 子类 ，这意味着 Original 类型的值不能用于 Derived 类型的值需要的地方。当您想以最小的运行时间成本防止逻辑错误时，这非常有用。
3.5.2 新版功能.
期望特定签名的回调函数的框架可以将类型标注为 Callable[[Arg1Type, Arg2Type], ReturnType]。
例如
通过用文字省略号替换类型提示中的参数列表： Callable[...，ReturnType]，可以声明可调用的返回类型，而无需指定调用签名。
由于无法以通用方式静态推断有关保存在容器中的对象的类型信息，因此抽象基类已扩展为支持订阅以表示容器元素的预期类型。
泛型可以通过使用typing模块中名为 TypeVar 的新工厂进行参数化。
用户定义的类可以定义为泛型类。
Generic[T] 作为基类定义了类 LoggedVar 采用单个类型参数 T。这也使得 T 作为类体内的一个类型有效。
The Generic base class defines __class_getitem__() so that
LoggedVar[t] is valid as a type:
泛型类型可以有任意数量的类型变量，并且类型变量可能会受到限制:
Generic 每个参数的类型变量必须是不同的。这是无效的:
您可以对 Generic 使用多重继承:
从泛型类继承时，某些类型变量可能是固定的:
在这种情况下，MyDict 只有一个参数，T。
在不指定类型参数的情况下使用泛型类别会为每个位置假设 Any。在下面的例子中，MyIterable 不是泛型，但是隐式继承自 Iterable[Any]:
用户定义的通用类型别名也受支持。例子:
在 3.7 版更改: Generic no longer has a custom metaclass.
A user-defined generic class can have ABCs as base classes without a metaclass
conflict. Generic metaclasses are not supported. The outcome of parameterizing
generics is cached, and most types in the typing module are hashable and
comparable for equality.
Any 是一种特殊的类型。静态类型检查器将所有类型视为与 Any 兼容，反之亦然， Any 也与所有类型相兼容。
这意味着可对类型为 Any 的值执行任何操作或方法调用，并将其赋值给任何变量:
需要注意的是，将 Any 类型的值赋值给另一个更具体的类型时，Python不会执行类型检查。例如，当把 a 赋值给 s 时，即使 s 被声明为 str 类型，在运行时接收到的是 int 值，静态类型检查器也不会报错。
此外，所有返回值无类型或形参无类型的函数将隐式地默认使用 Any 类型:
当需要混用动态类型和静态类型的代码时，上述行为可以让 Any 被用作 应急出口 。
Any 和 object 的行为对比。与 Any 相似，所有的类型都是 object 的子类型。然而不同于 Any，反之并不成立： object 不是 其他所有类型的子类型。
这意味着当一个值的类型是 object 的时候，类型检查器会拒绝对它的几乎所有的操作。把它赋值给一个指定了类型的变量（或者当作返回值）是一个类型错误。比如说：
使用 object 示意一个值可以类型安全地兼容任何类型。使用 Any 示意一个值地类型是动态定义的。
Initially PEP 484 defined Python static type system as using
nominal subtyping. This means that a class A is allowed where
a class B is expected if and only if A is a subclass of B.
This requirement previously also applied to abstract base classes, such as
Iterable. The problem with this approach is that a class had
to be explicitly marked to support them, which is unpythonic and unlike
what one would normally do in idiomatic dynamically typed Python code.
For example, this conforms to the PEP 484:
PEP 544 allows to solve this problem by allowing users to write
the above code without explicit base classes in the class definition,
allowing Bucket to be implicitly considered a subtype of both Sized
and Iterable[int] by static type checkers. This is known as
structural subtyping (or static duck-typing):
Moreover, by subclassing a special class Protocol, a user
can define new custom protocols to fully enjoy structural subtyping
(see examples below).
这个模块定义了如下的类,模块和修饰器.
类型变量
用法:
Type variables exist primarily for the benefit of static type
checkers.  They serve as the parameters for generic types as well
as for generic function definitions.  See class Generic for more
information on generic types.  Generic functions work as follows:
The latter example's signature is essentially the overloading
of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note
that if the arguments are instances of some subclass of str,
the return type is still plain str.
isinstance(x, T) 会在运行时抛出 TypeError 异常。一般地说， isinstance() 和 issubclass() 不应该和类型一起使用。
Type variables may be marked covariant or contravariant by passing
covariant=True or contravariant=True.  See PEP 484 for more
details.  By default type variables are invariant.  Alternatively,
a type variable may specify an upper bound using bound=&lt;type&gt;.
This means that an actual type substituted (explicitly or implicitly)
for the type variable must be a subclass of the boundary type,
see PEP 484.
Abstract base class for generic types.
A generic type is typically declared by inheriting from an
instantiation of this class with one or more type variables.
For example, a generic mapping type might be defined as:
这个类之后可以被这样用:
Base class for protocol classes. Protocol classes are defined like this:
Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example:
See PEP 544 for details. Protocol classes decorated with
runtime_checkable() (described later) act as simple-minded runtime
protocols that check only the presence of given attributes, ignoring their
type signatures.
Protocol classes can be generic, for example:
3.8 新版功能.
A variable annotated with C may accept a value of type C. In
contrast, a variable annotated with Type[C] may accept values that are
classes themselves -- specifically, it will accept the class object of
C. For example:
Note that Type[C] is covariant:
The fact that Type[C] is covariant implies that all subclasses of
C should implement the same constructor signature and class method
signatures as C. The type checker should flag violations of this,
but should also allow constructor calls in subclasses that match the
constructor calls in the indicated base class. How the type checker is
required to handle this particular case may change in future revisions of
PEP 484.
The only legal parameters for Type are classes, Any,
type variables, and unions of any of these types.
For example:
Type[Any] is equivalent to Type which in turn is equivalent
to type, which is the root of Python's metaclass hierarchy.
3.5.2 新版功能.
collections.abc.Iterable 的泛型版本。
collections.abc.Iterator 的泛型版本。
collections.abc.Reversible 的泛型版本。
An ABC with one abstract method __int__.
An ABC with one abstract method __float__.
An ABC with one abstract method __complex__.
An ABC with one abstract method __bytes__.
An ABC with one abstract method __index__.
3.8 新版功能.
An ABC with one abstract method __abs__ that is covariant
in its return type.
An ABC with one abstract method __round__
that is covariant in its return type.
collections.abc.Container 的泛型版本。
collections.abc.Hashable 的别名。
collections.abc.Sized 的别名。
collections.abc.Collection 的泛型版本。
3.6.0 新版功能.
collections.abc.Set  的泛型版本。
collections.abc.MutableSet 的泛型版本。
collections.abc.Mapping 的泛型版本。这个类型可以如下使用:
collections.abc.MutableMapping 的泛型版本。
collections.abc.Sequence 的泛型版本。
collections.abc.MutableSequence 的泛型版本。
collections.abc.ByteString 的泛型版本。
This type represents the types bytes, bytearray,
and memoryview of byte sequences.
As a shorthand for this type, bytes can be used to
annotate arguments of any of the types mentioned above.
collections.deque 的泛型版本。
3.5.4 新版功能.
3.6.1 新版功能.
Generic version of list.
Useful for annotating return types. To annotate arguments it is preferred
to use an abstract collection type such as Sequence or
Iterable.
这个类型可以这样用:
A generic version of builtins.set.
Useful for annotating return types. To annotate arguments it is preferred
to use an abstract collection type such as AbstractSet.
A generic version of builtins.frozenset.
collections.abc.MappingView 的泛型版本。
collections.abc.KeysView 的泛型版本。
collections.abc.ItemsView 的泛型版本。
collections.abc.ValuesView 的泛型版本。
collections.abc.Awaitable 的泛型版本。
3.5.2 新版功能.
A generic version of collections.abc.Coroutine.
The variance and order of type variables
correspond to those of Generator, for example:
3.5.3 新版功能.
collections.abc.AsyncIterable 的泛型版本。
3.5.2 新版功能.
collections.abc.AsyncIterator 的泛型版本。
3.5.2 新版功能.
contextlib.AbstractContextManager 的泛型版本。
3.5.4 新版功能.
3.6.0 新版功能.
contextlib.AbstractAsyncContextManager 的泛型版本。
3.5.4 新版功能.
3.6.2 新版功能.
dict 的泛型版本。对标注返回类型比较有用。如果要标注参数的话，使用如 Mapping 的抽象容器类型是更好的选择。
这个类型可以这样使用:
collections.defaultdict 的泛型版本。
3.5.2 新版功能.
collections.OrderedDict 的泛型版本。
3.7.2 新版功能.
collections.Counter 的泛型版本。
3.5.4 新版功能.
3.6.1 新版功能.
collections.ChainMap 的泛型版本。
3.5.4 新版功能.
3.6.1 新版功能.
A generator can be annotated by the generic type
Generator[YieldType, SendType, ReturnType]. For example:
Note that unlike many other generics in the typing module, the SendType
of Generator behaves contravariantly, not covariantly or
invariantly.
If your generator will only yield values, set the SendType and
ReturnType to None:
Alternatively, annotate your generator as having a return type of
either Iterable[YieldType] or Iterator[YieldType]:
An async generator can be annotated by the generic type
AsyncGenerator[YieldType, SendType]. For example:
Unlike normal generators, async generators cannot return a value, so there
is no ReturnType type parameter. As with Generator, the
SendType behaves contravariantly.
If your generator will only yield values, set the SendType to
None:
Alternatively, annotate your generator as having a return type of
either AsyncIterable[YieldType] or AsyncIterator[YieldType]:
3.6.1 新版功能.
Text is an alias for str. It is provided to supply a forward
compatible path for Python 2 code: in Python 2, Text is an alias for
unicode.
Use Text to indicate that a value must contain a unicode string in
a manner that is compatible with both Python 2 and Python 3:
3.5.2 新版功能.
Generic type IO[AnyStr] and its subclasses TextIO(IO[str])
and BinaryIO(IO[bytes])
represent the types of I/O streams such as returned by
open().
These type aliases
correspond to the return types from re.compile() and
re.match().  These types (and the corresponding functions)
are generic in AnyStr and can be made specific by writing
Pattern[str], Pattern[bytes], Match[str], or
Match[bytes].
Typed version of collections.namedtuple().
用法:
这相当于:
To give a field a default value, you can assign to it in the class body:
Fields with a default value must come after any fields without a default.
The resulting class has an extra attribute __annotations__ giving a
dict that maps the field names to the field types.  (The field names are in
the _fields attribute and the default values are in the
_field_defaults attribute both of which are part of the namedtuple
API.)
NamedTuple subclasses can also have docstrings and methods:
Backward-compatible usage:
在 3.6 版更改: Added support for PEP 526 variable annotation syntax.
在 3.6.1 版更改: Added support for default values, methods, and docstrings.
Deprecated since version 3.8, will be removed in version 3.9: Deprecated the _field_types attribute in favor of the more
standard __annotations__ attribute which has the same information.
在 3.8 版更改: The _field_types and __annotations__ attributes are
now regular dictionaries instead of instances of OrderedDict.
A simple typed namespace. At runtime it is equivalent to
a plain dict.
TypedDict creates a dictionary type that expects all of its
instances to have a certain set of keys, where each key is
associated with a value of a consistent type. This expectation
is not checked at runtime but is only enforced by type checkers.
Usage:
The type info for introspection can be accessed via Point2D.__annotations__
and Point2D.__total__.  To allow using this feature with older versions
of Python that do not support PEP 526, TypedDict supports two additional
equivalent syntactic forms:
By default, all keys must be present in a TypedDict. It is possible
to override this by specifying totality.
Usage:
This means that a point2D TypedDict can have any of the keys omitted. A type
checker is only expected to support a literal False or True as the value of
the total argument. True is the default, and makes all items defined in the
class body be required.
See PEP 589 for more examples and detailed rules of using TypedDict.
3.8 新版功能.
A class used for internal typing representation of string forward references.
For example, List["SomeClass"] is implicitly transformed into
List[ForwardRef("SomeClass")].  This class should not be instantiated by
a user, but may be used by introspection tools.
A helper function to indicate a distinct type to a typechecker,
see NewType. At runtime it returns a function that returns
its argument. Usage:
3.5.2 新版功能.
Cast a value to a type.
This returns the value unchanged.  To the type checker this
signals that the return value has the designated type, but at
runtime we intentionally don't check anything (we want this
to be as fast as possible).
返回一个字典，字典内含有函数、方法、模块或类对象的类型提示。
This is often the same as obj.__annotations__. In addition,
forward references encoded as string literals are handled by evaluating
them in globals and locals namespaces. If necessary,
Optional[t] is added for function and method annotations if a default
value equal to None is set. For a class C, return
a dictionary constructed by merging all the __annotations__ along
C.__mro__ in reverse order.
Provide basic introspection for generic types and special typing forms.
For a typing object of the form X[Y, Z, ...] these functions return
X and (Y, Z, ...). If X is a generic alias for a builtin or
collections class, it gets normalized to the original class.
For unsupported objects return None and () correspondingly.
Examples:
3.8 新版功能.
The @overload decorator allows describing functions and methods
that support multiple different combinations of argument types. A series
of @overload-decorated definitions must be followed by exactly one
non-@overload-decorated definition (for the same function/method).
The @overload-decorated definitions are for the benefit of the
type checker only, since they will be overwritten by the
non-@overload-decorated definition, while the latter is used at
runtime but should be ignored by a type checker.  At runtime, calling
a @overload-decorated function directly will raise
NotImplementedError. An example of overload that gives a more
precise type than can be expressed using a union or a type variable:
See PEP 484 for details and comparison with other typing semantics.
A decorator to indicate to type checkers that the decorated method
cannot be overridden, and the decorated class cannot be subclassed.
For example:
There is no runtime checking of these properties. See PEP 591 for
more details.
3.8 新版功能.
用于指明标注不是类型提示的装饰器。
此 decorator 装饰器生效于类或函数上。如果作用于类上的话，它会递归地作用于这个类的所定义的所有方法上（但是对于超类或子类所定义的方法不会生效）。
此方法会就地地修改函数。
使其它装饰器起到 no_type_check() 效果的装饰器。
This wraps the decorator with something that wraps the decorated
function in no_type_check().
标记一个类或函数在运行时内不可用的装饰器。
This decorator is itself not available at runtime. It is mainly
intended to mark classes that are defined in type stub files if
an implementation returns an instance of a private class:
Note that returning instances of private classes is not recommended.
It is usually preferable to make such classes public.
Mark a protocol class as a runtime protocol.
Such a protocol can be used with isinstance() and issubclass().
This raises TypeError when applied to a non-protocol class.  This
allows a simple-minded structural check, very similar to "one trick ponies"
in collections.abc such as Iterable.  For example:
Warning: this will check only the presence of the required methods,
not their type signatures!
3.8 新版功能.
特殊类型，表明类型没有任何限制。
每一个类型都对 Any 兼容。
Any 对每一个类型都兼容。
标记一个函数没有返回值的特殊类型。比如说:
3.5.4 新版功能.
3.6.2 新版功能.
联合类型； Union[X, Y] 意味着：要不是 X，要不是 Y。
使用形如 Union[int, str] 的形式来定义一个联合类型。细节如下:
参数必须是类型，而且必须至少有一个参数。
联合类型的联合类型会被展开打平，比如:
仅有一个参数的联合类型会坍缩成参数自身，比如:
多余的参数会被跳过，比如:
在比较联合类型的时候，参数顺序会被忽略，比如:
你不能继承或者实例化一个联合类型。
你不能写成 Union[X][Y] 。
你可以使用 Optional[X] 作为 Union[X, None] 的缩写。
在 3.7 版更改: 不要在运行时内从联合类型中移除显式说明的子类。
Optional type.
Optional[X] is equivalent to Union[X, None].
Note that this is not the same concept as an optional argument,
which is one that has a default.  An optional argument with a
default does not require the Optional qualifier on its type
annotation just because it is optional. For example:
On the other hand, if an explicit value of None is allowed, the
use of Optional is appropriate, whether the argument is optional
or not. For example:
Tuple type; Tuple[X, Y] is the type of a tuple of two items
with the first item of type X and the second of type Y. The type of
the empty tuple can be written as Tuple[()].
Example: Tuple[T1, T2] is a tuple of two elements corresponding
to type variables T1 and T2.  Tuple[int, float, str] is a tuple
of an int, a float and a string.
To specify a variable-length tuple of homogeneous type,
use literal ellipsis, e.g. Tuple[int, ...]. A plain Tuple
is equivalent to Tuple[Any, ...], and in turn to tuple.
Callable type; Callable[[int], str] is a function of (int) -&gt; str.
The subscription syntax must always be used with exactly two
values: the argument list and the return type.  The argument list
must be a list of types or an ellipsis; the return type must be
a single type.
There is no syntax to indicate optional or keyword arguments;
such function types are rarely used as callback types.
Callable[..., ReturnType] (literal ellipsis) can be used to
type hint a callable taking any number of arguments and returning
ReturnType.  A plain Callable is equivalent to
Callable[..., Any], and in turn to
collections.abc.Callable.
A type that can be used to indicate to type checkers that the
corresponding variable or function parameter has a value equivalent to
the provided literal (or one of several literals). For example:
Literal[...] cannot be subclassed. At runtime, an arbitrary value
is allowed as type argument to Literal[...], but type checkers may
impose restrictions. See PEP 586 for more details about literal types.
3.8 新版功能.
Special type construct to mark class variables.
As introduced in PEP 526, a variable annotation wrapped in ClassVar
indicates that a given attribute is intended to be used as a class variable
and should not be set on instances of that class. Usage:
ClassVar accepts only types and cannot be further subscribed.
ClassVar is not a class itself, and should not
be used with isinstance() or issubclass().
ClassVar does not change Python runtime behavior, but
it can be used by third-party type checkers. For example, a type checker
might flag the following code as an error:
3.5.3 新版功能.
A special typing construct to indicate to type checkers that a name
cannot be re-assigned or overridden in a subclass. For example:
There is no runtime checking of these properties. See PEP 591 for
more details.
3.8 新版功能.
AnyStr is a type variable defined as
AnyStr = TypeVar('AnyStr', str, bytes).
It is meant to be used for functions that may accept any kind of string
without allowing different kinds of strings to mix. For example:
A special constant that is assumed to be True by 3rd party static
type checkers. It is False at runtime. Usage:
Note that the first type annotation must be enclosed in quotes, making it a
"forward reference", to hide the expensive_mod reference from the
interpreter runtime.  Type annotations for local variables are not
evaluated, so the second annotation does not need to be enclosed in quotes.
3.5.2 新版功能.
开发工具
pydoc --- 文档生成器和在线帮助系统
</body></doc>